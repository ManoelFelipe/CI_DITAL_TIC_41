
# Projeto `comp_2` — Comparador de Igualdade de 2 bits

## 5.1 Descrição do Projeto

Autor: *Manoel Furtado*  
Data: *15/11/2025*  

O projeto `comp_2` implementa um circuito combinacional simples e ao mesmo tempo extremamente recorrente em arquiteturas digitais: um comparador de igualdade de 2 bits. O bloco recebe dois vetores de entrada, `a[1:0]` e `b[1:0]`, e produz uma única saída, `igual_flag`, que assume nível lógico alto quando os dois vetores são exatamente iguais e nível lógico baixo quando existe qualquer diferença entre os bits correspondentes. Apesar da largura reduzida, o módulo é construído de forma didática em três estilos distintos de descrição em Verilog — behavioral, dataflow e structural — permitindo comparar não apenas o resultado funcional final, mas também a legibilidade do código, a transparência da intenção de projeto e o impacto potencial sobre a síntese em ferramentas como Quartus e Questa.

A arquitetura é puramente combinacional, sem elementos de memória, o que garante latência de um único estágio lógico (ou poucos níveis de portas, dependendo do mapeamento físico). Em uma implementação típica, a versão estrutural se traduz em duas portas XNOR seguidas de uma porta AND, formando uma profundidade lógica pequena e previsível. Já a versão dataflow encapsula essa estrutura em uma expressão booleana compacta, enquanto a versão behavioral entrega a mesma função utilizando comparações de vetores de mais alto nível. Em todos os casos, a intenção é que o comparador possa ser utilizado como bloco de decisão em unidades maiores, como ALUs, máquinas de estados ou módulos de controle, servindo tanto para checagem de igualdade de contadores quanto para comparação de códigos de operação ou flags de protocolo.

O projeto está organizado em uma árvore de diretórios que separa claramente os artefatos destinados ao Quartus e ao Questa. Cada abordagem possui seu próprio arquivo `comp_2.v` em subpastas `behavioral`, `dataflow` e `structural`, mantendo modularidade e facilitando o reuso. Além disso, há um testbench auto-verificante compartilhado e um conjunto de scripts `.do` que automatizam a limpeza, compilação e execução das simulações. O objetivo final é oferecer um exemplo pequeno, porém completo, de fluxo de desenvolvimento HDL, cobrindo desde a descrição RTL até a verificação automatizada, pronto para ser expandido para comparadores de maior largura ou integrados em pipelines mais complexos.

## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

A implementação **behavioral** do `comp_2` busca expressar o comportamento do comparador em um nível de abstração próximo à especificação textual: “saída igual a 1 quando as duas entradas forem exatamente iguais”. Nesse estilo, utiliza-se um bloco `always @*` com uma instrução condicional `if (a == b)` que compara diretamente os vetores de 2 bits. A síntese interpreta essa comparação como uma igualdade bit a bit, gerando internamente lógica XNOR/AND equivalente. A principal vantagem é a clareza para quem está iniciando: a leitura do código revela, de imediato, a intenção de verificar igualdade. Em termos de riscos, é importante garantir que todas as saídas sejam atribuídas em todos os ramos do `if` para evitar a inferência acidental de latches, o que é mitigado aqui pelo uso explícito do ramo `else` atribuindo `0` à saída. Como o módulo é puramente combinacional, a latência permanece baixa e o custo em área é mínimo, independente do estilo.

Na abordagem **dataflow**, a mesma função é implementada por meio de uma expressão booleana contínua: `assign igual_flag = (a[1] ~^ b[1]) & (a[0] ~^ b[0]);`. O operador XNOR (`~^`) é particularmente adequado porque retorna `1` quando os bits são iguais, exatamente o que se deseja em cada posição do vetor. A combinação dessas comparações por uma porta AND garante que a saída global seja `1` apenas quando os dois bits individuais coincidirem. Esse estilo torna a estrutura lógica explícita, refletindo quase literalmente o esquema de portas que se espera ver no nível de porta. Em termos de síntese, a implementação tende a ser mapeada diretamente em duas XNOR e uma AND, com pouquíssimo espaço para mal-entendidos da ferramenta, o que é útil em projetos onde se busca controle detalhado sobre o caminho crítico e o número de níveis lógicos.

Já a implementação **structural** vai além e instancia explicitamente portas primitivas `xnor` e `and`, além de sinais internos `bit1_igual` e `bit0_igual`. Essa forma de descrição se aproxima do diagrama esquemático tradicional, facilitando o processo de depuração didática e a visualização do fluxo de sinais. Por outro lado, ela aumenta a verbosidade e reduz a portabilidade entre tecnologias que eventualmente não disponham das mesmas primitivas nomeadas, embora em Verilog padrão isso normalmente não seja um problema. Em aplicações reais, a escolha entre behavioral, dataflow e structural depende do compromisso entre legibilidade, controle de síntese e esforço de manutenção. Para comparadores simples, as três abordagens resultam, em geral, em hardware idêntico; porém, em blocos maiores, diferenças de estilo podem impactar o balanceamento de profundidade lógica, o uso de recursos dedicados (como LUTs ou portas especiais) e até o esforço do sintetizador em realizar otimizações mais agressivas.

## 5.3 Descrição do Testbench e Metodologia de Simulação

O testbench `tb_comp_2` foi projetado como um ambiente auto-verificante capaz de explorar todas as combinações possíveis de entrada para o comparador de 2 bits, garantindo cobertura funcional completa de forma sistemática. As entradas `tb_a` e `tb_b` são declaradas como `reg [1:0]`, permitindo atribuições sequenciais ao longo do tempo de simulação, enquanto a saída `tb_igual_flag` é conectada ao dispositivo sob teste (DUT) como um `wire`. Um registrador adicional, `expected_igual_flag`, funciona como “modelo de referência” (golden model), calculando em software a igualdade entre `tb_a` e `tb_b` a cada vetor aplicado. Um contador inteiro `error_count` acumula o número de divergências observadas entre o DUT e o modelo, proporcionando uma métrica clara de sucesso ou falha ao término da campanha de testes.

A geração de estímulos é realizada por dois laços aninhados `for`, varrendo `i` e `j` de 0 a 3, cobrindo assim as 16 combinações possíveis de pares `(a, b)` em 2 bits. A cada iteração, os índices são convertidos em vetores de 2 bits por meio de `i[1:0]` e `j[1:0]`, garantindo que apenas os bits menos significativos sejam aplicados às entradas. Entre as atribuições e a checagem são inseridos atrasos `#5`, simulando o tempo de propagação e assegurando que as mudanças se reflitam corretamente no DUT antes da comparação. Em seguida, o testbench calcula `expected_igual_flag = (tb_a == tb_b)` e confronta esse valor com `tb_igual_flag`. Caso haja mismatch, uma mensagem detalhada é reportada com os valores de entrada, saída, valor esperado e timestamp da simulação; em caso de acerto, uma mensagem de confirmação é exibida, auxiliando na análise das formas de onda.

Além da verificação lógica, o testbench configura a geração de um arquivo de ondas VCD por meio de `initial begin $dumpfile("wave.vcd"); $dumpvars(0, tb_comp_2); end`, permitindo inspeções visuais posteriores em ferramentas como GTKWave. Essa prática é essencial para depurar erros sutis de temporização ou conexões equivocadas em projetos maiores, mesmo quando a verificação automática não indica falhas. Ao final dos loops, o testbench avalia `error_count` e imprime um resumo global indicando se todas as combinações passaram ou quantos erros foram detectados. Por fim, a chamada a `$finish` encerra a simulação de forma limpa, favorecendo a automatização via scripts de linha de comando (`run_cli.do`). Essa abordagem torna o ambiente facilmente reaproveitável para diferentes versões do `comp_2`, sejam elas behavioral, dataflow ou structural, bastando trocar o arquivo RTL compilado sem alterar o testbench.

## 5.4 Aplicações Práticas e Extensões do Comparador de 2 bits

Embora o comparador de 2 bits pareça, à primeira vista, um bloco elementar, ele representa um tijolo fundamental em diversas arquiteturas digitais reais. Em muitos processadores e controladores embarcados, comparadores de pequena largura são encadeados para implementar unidades de decisão mais complexas, como decodificadores de instrução, blocos de detecção de zero em acumuladores e verificadores de códigos de operação. Por exemplo, em uma ALU simples responsável por operações aritméticas e lógicas em 8 bits, comparadores intermediários podem ser utilizados para checar flags de igualdade, detectar overflow assinado ou mesmo implementar lógicas de branch condicionais baseadas na comparação entre registradores. O `comp_2`, nesse contexto, pode ser replicado e concatenado para formar comparadores de 4, 8 ou 16 bits, com pouca alteração estrutural, mantendo a mesma ideia de XNORs seguidas por ANDs.

Em sistemas de comunicação digital, comparadores de igualdade são frequentemente empregados para detecção de sequências de controle ou cabeçalhos de protocolo. Imagine, por exemplo, um barramento serial simples em que determinados símbolos de 2 bits representam estados específicos, como “início de quadro”, “fim de quadro” ou “código de erro”. O comparador `comp_2` pode ser ligado diretamente à saída do deserializador, disparando eventos de controle quando um símbolo esperado é recebido. Essa abordagem permite implementar máquinas de estados com transições condicionadas pela igualdade entre o símbolo recebido e um padrão pré-definido, simplificando o desenho do diagrama de estados e a lógica de transição.

Outra aplicação prática relevante está em circuitos de proteção e intertravamento industrial, onde a igualdade entre sinais redundantes é usada para detectar falhas de sensores ou inconsistências de leitura. Dois canais independentes podem medir a mesma grandeza discretizada em 2 bits e, ao cruzar suas leituras em um comparador, é possível sinalizar rapidamente quando há divergência, indicando potencial falha de hardware. Embora na prática se utilizem larguras maiores e técnicas adicionais de diagnóstico, o princípio de operação é o mesmo do `comp_2`. Do ponto de vista de projeto, boas práticas incluem parametrizar a largura do comparador para facilitar reuso, organizar o código em módulos reutilizáveis e integrar testbenches auto-verificantes como o apresentado aqui, o que reduz o risco de regressões quando o bloco é expandido. Além disso, a separação em abordagens behavioral, dataflow e structural fornece um laboratório ideal para avaliar como diferentes estilos de descrição influenciam a síntese, o timing e a depuração em projetos embarcados reais, preparando o caminho para o desenvolvimento de comparadores mais avançados e de blocos de controle robustos em FPGA ou ASIC.
