# Projeto mux_2_1 — Multiplexador 2:1 com vetor de entradas d[1:0]

## 5.1 Descrição do Projeto

Autor: *Manoel Furtado*  
Data: *15/11/2025*  

Este projeto implementa um multiplexador 2:1 síncrono em termos de interface, porém puramente combinacional em sua lógica interna, utilizando um vetor de dados de duas posições `d[1:0]` e um sinal de seleção escalar `sel`. A função principal do bloco é encaminhar para a saída `y` um dos dois bits de entrada, de forma que, quando `sel = 0`, o valor de `d[0]` é propagado, e quando `sel = 1`, o valor de `d[1]` é refletido na saída. Essa modelagem é especialmente útil em arquiteturas digitais onde se deseja agrupar linhas de dados relacionadas em vetores, facilitando a indexação e o roteamento interno em barramentos mais amplos.

A arquitetura foi desenvolvida em três estilos distintos de descrição em Verilog 2001: comportamental (behavioral), fluxo de dados (dataflow) e estrutural (structural). Em todos os casos, a interface do módulo é idêntica, garantindo que qualquer uma das abordagens possa ser utilizada de forma intercambiável em projetos maiores. O uso do padrão de nomes em *snake_case* e a organização em diretórios separados por ferramenta (Quartus e Questa) têm o objetivo de reforçar boas práticas de engenharia, permitindo migração mais simples entre ambientes de síntese e simulação.

Do ponto de vista de recursos, o multiplexador 2:1 é um bloco extremamente compacto, sintetizando tipicamente em poucas portas lógicas ou em uma única LUT em FPGAs modernos. Não há elementos de memória nem dependência de clock, o que implica latência puramente combinacional e atraso limitado pela profundidade de lógica da implementação adotada. Essas características tornam o componente adequado para integrações em caminhos de dados críticos, desde que o atraso de propagação seja contabilizado no fechamento de temporização.

Além do núcleo do multiplexador, o projeto inclui um testbench auto-verificante (`tb_mux_2_1`) e um conjunto de scripts `.do` para o ambiente Questa/ModelSim. O testbench exercita exaustivamente todas as combinações de entradas, compara os resultados observados com o valor esperado `d[sel]` e gera um arquivo de formas de onda (`wave.vcd`). Assim, o projeto não apenas apresenta a lógica do mux, mas também demonstra um fluxo de verificação completo, que pode ser reutilizado em outros blocos combinacionais simples.


## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

Na abordagem **behavioral**, o multiplexador é descrito por meio de um bloco `always @*` e uma estrutura condicional `if/else`. A saída `y` é declarada como `reg`, e seu valor é atualizado de forma combinacional sempre que houver alteração em qualquer uma das entradas. O código segue o padrão: se `sel == 0`, então `y = d[0]`, caso contrário `y = d[1]`. Essa forma de modelagem é extremamente legível para quem está iniciando no estudo de multiplexadores, pois traduz de forma quase literal a ideia de escolher entre duas opções com base em uma condição booleana. Em termos de síntese, ferramentas como o Quartus convertem esse `if/else` em um arranjo de portas equivalente a um mux 2:1 clássico. O risco principal, ao se trabalhar com descrição comportamental, é o surgimento acidental de *latches* caso nem todos os caminhos de decisão atribuam valor à saída; nesse projeto, esse problema é evitado porque todas as ramificações do `if/else` atribuem explicitamente `y`.

Na abordagem **dataflow**, o mesmo comportamento é obtido utilizando uma única atribuição contínua com o operador condicional `? :`. Neste caso, `y` é declarado como `wire`, e a expressão `assign y = (sel == 1'b0) ? d[0] : d[1];` implementa diretamente a função do mux. Essa forma de modelagem tende a resultar em código mais compacto, com menos linhas e maior ênfase na expressão lógica. Para multiplexadores simples, essa abordagem é bastante comum e muitas vezes preferida em projetos industriais, pois torna evidente a natureza puramente combinacional do bloco. Além disso, o operador condicional apresenta boa compatibilidade com síntese, sendo mapeado para a mesma estrutura de portas ou LUTs gerada a partir da descrição comportamental. Um benefício adicional é a redução do risco de criação de latches, já que a atribuição contínua sempre define o valor de saída para todas as combinações de entradas.

Já a abordagem **structural** explora explicitamente a decomposição do multiplexador em portas lógicas primitivas. O código instancia um inversor para gerar `not_sel = ~sel`, duas portas AND para combinar `d[0]` com `not_sel` e `d[1]` com `sel`, e uma porta OR para reunir as duas contribuições na saída `y`. Em termos de leitura, essa implementação reforça a visão do mux como composição de blocos elementares: `y = (d[0] AND ~sel) OR (d[1] AND sel)`. Embora mais verboso, o estilo estrutural é valioso para fins didáticos e para projetos em que se deseja controle absoluto sobre a decomposição em portas, por exemplo ao direcionar síntese para bibliotecas específicas de células padrão. Em FPGAs, a ferramenta geralmente recompacta essas portas em LUTs equivalentes, mas o código estrutural ajuda a compreender o caminho de propagação e potenciais gargalos de temporização. Comparando as três abordagens, observa-se que todas devem produzir resultados funcionais idênticos e praticamente o mesmo custo de área; a escolha tende a ser guiada pela legibilidade desejada, pelo estilo da equipe e pelo nível de abstração adequado a cada estágio do projeto.


## 5.3 Descrição do Testbench e Metodologia de Simulação

O testbench `tb_mux_2_1` foi projetado para ser auto-verificante e exaustivo, cobrindo todas as combinações possíveis das entradas `d[1:0]` e do sinal de seleção `sel`. Como se trata de um multiplexador 2:1 de uma única saída, o espaço de entrada é pequeno: existem 4 combinações possíveis para `d` (de `2'b00` até `2'b11`) e 2 valores possíveis para `sel` (0 e 1), totalizando 8 vetores de teste. O testbench utiliza dois laços `for` aninhados. O laço externo percorre os valores de `d` de 0 a 3, atribuindo a cada iteração `d = i[1:0]`, de forma a gerar sequencialmente todas as combinações de bits. O laço interno percorre os valores de `sel` de 0 a 1, permitindo que, para cada configuração de `d`, sejam avaliados os dois caminhos possíveis do multiplexador. Em cada iteração, é inserido um atraso de 10 ns (`#10`) antes da verificação, garantindo tempo suficiente para que a lógica combinacional do DUT se estabilize.

A checagem funcional é feita comparando-se a saída observada `y` com o valor esperado `d[sel]`. A expressão `if (y !== d[sel])` é utilizada para capturar qualquer divergência, tratando inclusive estados desconhecidos (`X`) e de alta impedância (`Z`), graças ao operador de comparação case-equality (`!==`). Quando ocorre uma discrepância, o testbench incrementa um contador de erros e exibe uma mensagem detalhando a combinação de entrada, o valor observado, o valor esperado e o instante de tempo da falha. Em caso de sucesso em uma determinada combinação, uma mensagem “OK” também é impressa, reforçando a rastreabilidade dos vetores de teste aplicados. Ao final da varredura, são exibidos um sumário com o número total de vetores e a quantidade de erros encontrados, bem como uma mensagem conclusiva informando se o DUT passou ou não em todos os testes.

Além da verificação funcional, o testbench gera um arquivo de formas de onda no formato VCD (`wave.vcd`), configurado no bloco inicial que contém `$dumpfile` e `$dumpvars`. Esse arquivo pode ser analisado em ferramentas como GTKWave ou diretamente em ambientes com suporte a VCD, permitindo inspecionar a evolução temporal dos sinais `d`, `sel` e `y`. A presença dessa visualização é especialmente útil para fins didáticos, pois ajuda o projetista a confirmar que o comportamento temporal está de acordo com o esperado, identificando, por exemplo, se há glitches ou atrasos excessivos na propagação dos sinais. O testbench foi escrito para ser agnóstico em relação à implementação selecionada (behavioral, dataflow ou structural); o script `compile.do` é responsável por escolher qual versão do `mux_2_1` será instanciada, mantendo a mesma interface e o mesmo conjunto de testes. Dessa forma, é possível comparar diretamente as três abordagens sob o mesmo conjunto de estímulos e garantir que todas são funcionalmente equivalentes.


## 5.4 Aplicações Práticas do Multiplexador 2:1

O multiplexador 2:1 é um dos blocos fundamentais em projetos de sistemas digitais e aparece, de forma explícita ou implícita, em praticamente todas as arquiteturas de hardware modernas. Na prática, ele desempenha a função de “chave eletrônica” controlada por lógica, permitindo selecionar qual fonte de dados será encaminhada a um determinado destino. Um exemplo clássico é em unidades lógicas e aritméticas (ULAs), nas quais diferentes operações produzem resultados concorrentes e um multiplexador escolhe qual deles será levado adiante com base no código de operação. Embora o projeto atual trate apenas de um mux de 1 bit, a extensão para vetores maiores é imediata: basta replicar o bloco ou parametrizá-lo para operar sobre barramentos de N bits, selecionando entre diferentes fontes de dados em pipelines mais complexos.

Outra aplicação importante está em caminhos de dados de processadores e microcontroladores, onde multiplexadores são usados para escolher entre endereços de diferentes fontes (por exemplo, contador de programa, registradores de salto ou endereços calculados em estágio de execução) antes de alimentar a memória de instruções ou dados. Em arquiteturas de comunicação, multiplexadores servem para compartilhar um mesmo canal físico entre múltiplos sinais lógicos, aplicando técnicas de comutação por tempo ou por condição, de forma semelhante a um *switch* interno. A organização adotada neste projeto, em que as entradas são agrupadas em um vetor `d[1:0]`, é bastante alinhada a essas aplicações, pois facilita a criação de arranjos maiores em que o índice de seleção é interpretado como um endereço em um conjunto de linhas de dados.
 
No contexto de FPGAs e ASICs, multiplexadores também aparecem como elementos implícitos gerados pela síntese a partir de estruturas de controle de fluxo em HDL, como `if/else`, `case` ou operadores condicionais. Entender o comportamento de um mux 2:1 simples ajuda o projetista a interpretar relatórios de síntese e a antever o impacto de decisões de codificação na área e no atraso de propagação. Por exemplo, cadeias de multiplexadores podem introduzir caminhos críticos longos se conectadas em série, exigindo técnicas de balanceamento, introdução de estágios de pipeline ou reescrita da lógica para reduzir profundidade. Em aplicações de baixa potência, o uso de multiplexadores também deve ser analisado sob o ponto de vista de comutação desnecessária, buscando minimizar a quantidade de sinais que alternam estados em cada ciclo de operação.

Além dos exemplos mais clássicos, o multiplexador 2:1 pode ser utilizado como bloco de construção em componentes menos óbvios, como registradores com carga condicional, bancos de registradores com escrita seletiva ou módulos de correção de erros simples, em que dados originais e corrigidos são escolhidos com base em sinais de paridade. Em sistemas de aprendizado de máquina implementados em hardware, multiplexadores são empregados para alternar entre diferentes configurações de pesos ou dados de entrada durante fases de treino e inferência. O projeto apresentado, embora simples, serve como base sólida para tais aplicações: ao combinar três estilos de implementação, um testbench robusto e scripts de automação, ele demonstra um padrão de desenvolvimento profissional que pode ser replicado em blocos muito mais complexos.

