# Projeto conv_4_gray

## 5.1 Descricao do Projeto

Autor: Manoel Furtado  
Data: 15/11/2025  

O projeto `conv_4_gray` tem como objetivo implementar, analisar e validar um conversor combinacional de codigo binario para codigo Gray de 4 bits. Em um contador puramente binario, sucessivos valores podem diferir em varios bits simultaneamente, o que aumenta a probabilidade de glitches e leituras inconsistentes quando sinais passam por dominios de relogio diferentes ou chegam com atrasos desiguals em portas logicas. O codigo Gray, por sua vez, garante que entre dois valores consecutivos apenas um bit se altere, reduzindo significativamente a incidencia de erros de leitura em sistemas reais.

A arquitetura proposta recebe um vetor `bin_in[3:0]` e produz um vetor `gray_out[3:0]`, obedecendo as equacoes classicas: `G3 = B3`, `G2 = B3 XOR B2`, `G1 = B2 XOR B1` e `G0 = B1 XOR B0`. A escolha por uma largura fixa de 4 bits segue o enunciado da atividade, mas as tecnicas discutidas sao generalizaveis para N bits, bastando replicar o padrao de XOR entre vizinhos. Para fins de didatica e comparacao, o mesmo bloco funcional eh descrito em tres abordagens de Verilog 2001: behavioral, dataflow e structural.

O projeto foi organizado em uma estrutura de pastas separando claramente os artefatos para sintese em Quartus e para simulacao em Questa. Na pasta `Quartus/rtl` estao os arquivos destinados a sintese, enquanto em `Questa/rtl` e `Questa/tb` estao as versoes utilizadas para simulacao e verificacao automatizada. O testbench `tb_conv_4_gray.v` instancia simultaneamente as tres abordagens e percorre todos os 16 valores possiveis de entrada, calculando internamente o valor de referencia e comparando com cada implementacao. Alem disso, foram criados scripts `.do` para limpar o ambiente, compilar os arquivos e executar a simulacao tanto em modo grafico quanto em modo console, fornecendo um fluxo de trabalho reprodutivel, simples de acionar e alinhado as boas praticas de projetos HDL profissionais.


## 5.2 Analise das Abordagens

### Implementacao Behavioral

Na abordagem behavioral, o modulo `conv_4_gray_behavioral` utiliza um bloco `always @*` e atribuicoes procedurais para cada bit da saida. Essa forma de descricao e intuitiva para o projetista, pois permite raciocinar de forma algoritimica: dentro do bloco combinacional, para cada mudanca nas entradas, o hardware recalcula os bits de saida conforme as equacoes definidas. Por exemplo, para uma entrada binaria `bin_in = 4'b1010`, o bit mais significativo do Gray, `gray_out[3]`, recebe diretamente `1`. Em seguida, `gray_out[2]` recebe `1 XOR 0 = 1`, `gray_out[1]` recebe `0 XOR 1 = 1` e `gray_out[0]` recebe `1 XOR 0 = 1`, resultando em `1111`. A sintese transforma esse comportamento em portas XOR e fios, sem inserir registradores adicionais, ja que o bloco nao depende de borda de clock. A principal vantagem desta abordagem e a legibilidade do codigo, especialmente para estudantes, pois o fluxo do algoritmo fica explicito. Em contrapartida, e preciso atenção para que todas as atribuicoes sejam realizadas em todos os caminhos do bloco, evitando inferencia acidental de latches.

### Implementacao Dataflow

Na abordagem dataflow, o modulo `conv_4_gray_dataflow` utiliza somente atribuicoes continuas com `assign`. Cada bit da saida eh descrito por uma expressao booleana direta, como `assign gray_out[2] = bin_in[3] ^ bin_in[2];`. Essa forma favorece a visao puramente funcional do circuito, aproximando-se da algebra booleana e dos mapas de Karnaugh utilizados na etapa de projeto. Para o sintetizador, a traducao para portas fisicas eh praticamente direta: cada expressao XOR gera uma porta combinacional simples. Em termos de desempenho, a implementacao dataflow tende a ser equivalente a behavioral quando ambas descrevem a mesma logica pura, mas a abordagem dataflow estimula o projetista a pensar em termos de equacoes minimizadas, reduzindo o risco de descrever logica redundante. Uma boa pratica, quando a largura do barramento aumenta, e encapsular as equacoes em geradores parametrizados, utilizando operadores de deslocamento e concatenacao para manter o codigo enxuto.

### Implementacao Structural

Na abordagem estrutural, o modulo `conv_4_gray_structural` instancia portas elementares `xor2_gate` e sinais internos explicitando o fluxo de dados. Por exemplo, o sinal `g2_internal` recebe a saida de uma instancia `xor2_gate` cujas entradas sao `bin_in[3]` e `bin_in[2]`. O caminho completo ate a saida Gray fica, assim, detalhado pela hierarquia de instancias. Esse estilo se aproxima de um esquematico textual e e especialmente util quando se deseja mapear o projeto sobre uma biblioteca especifica de celulas padrao ou quando se quer demonstrar, didaticamente, a composicao do circuito. Em termos de sintese, a ausencia de operadores aritmeticos complexos torna o mapeamento bastante previsivel. A desvantagem eh o aumento do volume de codigo e o maior risco de erros de conexao manual, principalmente em projetos de maior escala. Para mitigar esse risco, recomenda-se adotar nomenclatura sistematica para instancias, documentar cada fio interno e, quando possivel, gerar automaticamente a estrutura a partir de descricoes mais abstratas.


## 5.3 Descricao do Testbench

O testbench `tb_conv_4_gray` foi concebido como um ambiente de verificacao auto-contido, capaz de exercitar e comparar simultaneamente as tres abordagens do conversor. Logo no inicio, sao declarados os sinais de estimulo `bin_in` e os fios de observacao `gray_behavioral`, `gray_dataflow` e `gray_structural`, correspondentes respectivamente as saidas das implementacoes behavioral, dataflow e estrutural. Um registrador adicional `gray_expected` armazena o valor de referencia calculado em tempo de simulacao, enquanto a variavel inteira `error_count` acumula o numero de discrepancias detectadas. Essa estrategia permite, ao final da simulacao, emitir uma unica mensagem de sucesso ou falha, facilitando a automatizacao de regressões.

A geracao de estimulos e realizada por meio de um laço `for`, que percorre todos os valores possiveis de um vetor de 4 bits, de `0000` a `1111`. Para cada iteracao, o indice `i` e atribuido a `bin_in`, ha um pequeno `#delay` para permitir a propagacao da logica combinacional nos DUTs, e em seguida o testbench calcula `gray_expected` a partir da mesma equacao utilizada no projeto: o bit mais significativo recebe diretamente `bin_in[3]`, enquanto os demais sao calculados com XOR entre vizinhos. Esse calculo interno emula, conceitualmente, um "modelo dourado" de referencia, contra o qual todas as implementacoes sao comparadas.

As verificacoes sao feitas com operadores de comparacao estrita (`!==`), de forma a capturar nao apenas discrepancias de valor logico mas tambem presenca de `X` ou `Z`, que indicariam problemas de inicializacao ou conflitos de direcao de porta. Para cada desvio, o testbench emite uma mensagem detalhada contendo o padrao de entrada, o valor esperado e o valor obtido, alem de incrementar o contador de erros. Em paralelo, sempre que um vetor eh aplicado, e impressa uma linha `INFO` com as tres saidas, facilitando a leitura do log e a correlacao com as formas de onda. O bloco inicial tambem habilita a geracao do arquivo `wave.vcd` por meio de `$dumpfile` e `$dumpvars`, o que permite inspecionar graficamente a evolucao dos sinais em ferramentas como GTKWave ou o proprio Visualizador de Ondas do Questa. Ao encerrar o laço, uma mensagem de "SUCESSO" eh exibida caso `error_count` seja zero; caso contrario, o numero total de falhas e reportado antes da chamada a `$finish`. Essa metodologia, embora simples, cobre exaustivamente o espaco de estados de entrada e garante alta confianca na equivalencia funcional entre as tres abordagens.


## 5.4 Aplicacoes Praticas

Conversores de codigo binario para Gray sao blocos fundamentais em diversos sistemas digitais nos quais a consistencia temporal das transicoes de sinais eh critica. Um exemplo classico sao os encoders incrementais de posicao, usados em motores e eixos mecanicos rotativos. Nesses dispositivos, o eixo mecanico aciona discos com janelas e sensores opticos que geram um padrao de bits proporcional ao angulo. Se o codigo fosse puramente binario, uma transicao como de `0111` (7) para `1000` (8) faria quatro bits mudarem ao mesmo tempo. Pequenas diferencas de atraso entre canais poderiam levar o circuito de leitura a observar estados intermediarios inexistentes, como `0100` ou `1101`, ocasionando erros de leitura de posicao. Ao utilizar codigo Gray, a transicao entre contagens sucessivas envolve apenas um bit, reduzindo drasticamente a probabilidade de leituras inconsistentes.

Outro cenário comum e em contadores assincronos e maquinas de estados que atravessam dominios de relogio distintos. Suponha, por exemplo, um contador de eventos em um dominio de alta frequencia que precisa ser lido por um processador em dominio mais lento. Se a contagem for transferida em binario, multiplos bits podem trocar de valor simultaneamente e, mesmo com tecnicas de sincronizacao de dois flip-flops, ha risco de metastabilidade e captura de combinacoes transitórias. Ao transmitir a contagem em Gray e depois reconverte-la para binario no dominio de destino, garante-se que apenas um bit atravesse fronteira de clock por vez, facilitando a sincronizacao correta. Em sistemas de comunicacao e codificacao de dados, o codigo Gray tambem aparece em modulacoes como QAM e PSK, em que os pontos da constelacao sao rotulados de forma a minimizar o numero de bits que mudam entre simbolos adjacentes, reduzindo a taxa de erro efetiva em canais ruidosos.

Em projetos FPGA educacionais, como o presente, a implementacao de conversores binario–Gray serve tambem como laboratorio para boas praticas de projeto. Permite exercitar uso de mapas de Karnaugh, comparacao de estilos de descricao HDL e construcao de testbenches auto-verificantes. Em aplicacoes industriais mais robustas, esses mesmos blocos podem ser encapsulados como IP reutilizavel, parametrizado em largura, integrando pipelines de processamento de sinais, sistemas de controle e interfaces de sensores. A combinacao de uma logica simples, de baixa area e com forte impacto na confiabilidade de leituras torna o conversor binario–Gray um componente pequeno, mas estrategico, dentro de arquiteturas digitais modernas.
