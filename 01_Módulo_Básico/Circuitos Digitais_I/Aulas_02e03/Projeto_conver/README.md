# Projeto_conver — Conversor BCD 5311 para BCD 8421

## 5.1 Descrição do Projeto

Autor: Manoel Furtado  
Data: 15/11/2025  

O projeto **Projeto_conver** implementa um conversor totalmente combinacional entre dois códigos decimais amplamente utilizados em sistemas digitais: o código BCD 5311, aplicado às entradas `H,G,F,E`, e o código BCD 8421, aplicado às saídas `D,C,B,A`. O código 5311 é um código ponderado não natural, no qual os pesos associados aos bits são 5‑3‑1‑1, enquanto o código 8421 corresponde ao BCD ponderado mais comum, com pesos 8‑4‑2‑1. Ambos permitem representar os dígitos decimais de 0 a 9 com quatro bits, porém com distribuições de padrões binários diferentes. O objetivo do projeto é receber, em hardware, um dígito codificado em 5311 e produzir na saída o mesmo dígito expresso em 8421, respeitando a tabela de conversão especificada pelo enunciado.

A arquitetura proposta é inteiramente **combinacional**, isto é, não há elementos de memória ou lógica sequencial. A transformação é feita em um único estágio de lógica, o que resulta em **latência de zero ciclos de clock** e torna o bloco apropriado para uso em pipelines de dados, unidades de entrada e saída de displays, ou interfaces de compatibilização de códigos. O projeto foi organizado de forma a suportar **três abordagens de implementação** distintas: behavioral, dataflow e structural. Cada abordagem é encapsulada em um módulo próprio (`conver_behavioral`, `conver_dataflow` e `conver_structural`) que compartilha a mesma interface, facilitando a comparação entre elas no mesmo testbench.

Do ponto de vista de fluxo de ferramentas, os arquivos foram separados em diretórios específicos para **Quartus** (foco em síntese e implementação em FPGA) e **Questa/ModelSim** (foco em simulação funcional). Essa separação torna o projeto mais limpo e alinhado com boas práticas de engenharia, permitindo reutilizar o mesmo código HDL em diferentes etapas do ciclo de desenvolvimento. Em particular, o diretório de simulação inclui todos os scripts `.do` necessários para limpeza, compilação e execução de simulações tanto em modo gráfico quanto em modo texto, garantindo reprodutibilidade.

## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

A implementação **behavioral** parte de uma visão de alto nível do problema. Em vez de descrever diretamente equações booleanas, o módulo `conver_behavioral` utiliza um bloco `always @*` com uma estrutura `case` indexada pelo vetor `{h,g,f,e}`. Cada combinação válida do código 5311 é mapeada explicitamente para o correspondente código 8421, por exemplo, `4'b0101` (decimal 4 em 5311) é associado a `4'b0100` (decimal 4 em 8421). Essa abordagem lembra uma LUT (lookup table) e é especialmente intuitiva quando temos uma tabela de conversão pequena e bem definida. Em termos de síntese, a ferramenta normalmente implementa essa descrição como uma pequena ROM combinacional ou como lógica de portas equivalente, sem impacto significativo em área para apenas 10 entradas válidas. A vantagem principal está na **clareza**: o engenheiro consegue conferir rapidamente se o mapeamento está correto apenas olhando o código.

Na abordagem **dataflow**, usada no módulo `conver_dataflow`, a preocupação é explicitar as **equações booleanas minimizadas**. A partir da tabela verdade, são obtidas expressões para D, C, B e A, como por exemplo `D = H & G` e `A = (!H & !G & !F & E) | (!H & G & !E) | (G & F) | (H & G & E) | (H & F)`. O foco aqui é evidenciar o fluxo de sinais e as combinações lógicas necessárias. Em síntese, essa abordagem costuma resultar em um circuito muito próximo da forma canônica minimizada, possivelmente utilizando menos portas do que uma descrição puramente behavioral, dependendo do otimizador da ferramenta. Por outro lado, a legibilidade pode se tornar mais difícil em expressões grandes, exigindo cuidado com parênteses, sinais de negação e consistência de variáveis.

Já a implementação **structural**, materializada em `conver_structural`, faz o caminho inverso: em vez de escrever equações em alto nível, decompõe a lógica em **instâncias explícitas de portas** (`and`, `or`, `not`) organizadas em submódulos. Cada bit de saída (D, C, B, A) é gerado por um módulo dedicado (`conver_d_struct`, `conver_c_struct`, etc.), que internamente utiliza apenas primitivas de porta. O módulo topo apenas interconecta esses blocos. Essa abordagem é ideal para fins didáticos, pois o estudante visualiza de maneira concreta como a equação é “quebrada” em portas elementares, incluindo sinais intermediários, inversores e construtores de termos. Em síntese, o resultado em área e timing tende a ser semelhante ao da implementação dataflow, mas a granularidade extra pode permitir análises mais detalhadas de atraso por estágio.

Comparando as três abordagens, podemos destacar que a behavioral é a mais rápida de escrever e revisar, a dataflow favorece a otimização algébrica e a structural traz o maior grau de controle e visibilidade sobre a topologia de portas. Em termos de riscos, a behavioral está mais sujeita a erros de digitação na tabela; a dataflow pode sofrer com parênteses incorretos; e a structural pode introduzir erros de conexão de fios, principalmente quando há muitos termos intermediários. Boas práticas incluem comentar cada bloco, validar com simulação exaustiva (como foi feito) e, se possível, revisar a lógica em par com outro desenvolvedor ou com ferramentas formais.

## 5.3 Descrição do Testbench e Metodologia de Simulação

O testbench `tb_conver` foi desenvolvido com o objetivo de ser **auto‑checável** e reutilizável, seguindo boas práticas de verificação para circuitos combinacionais. Logo no cabeçalho, define‑se `timescale 1ns/1ps`, garantindo que todos os atrasos `#10` sejam interpretados de forma consistente. As entradas do conversor são modeladas como registradores (`reg h, g, f, e`), enquanto as saídas de cada implementação são fios (`wire`) agrupados em vetores de 4 bits (`out_beh`, `out_df`, `out_st`). Essa organização facilita a comparação simultânea entre as três abordagens e permite exibir em uma única linha o resultado completo dos quatro bits de saída.

A metodologia começa com a construção de dois vetores de memória: `vec_in_5311`, contendo os dez códigos válidos do padrão 5311, e `vec_exp_8421`, contendo os respectivos códigos 8421 esperados. Esse preenchimento é feito em um bloco `initial`, de forma legível e comentada, espelhando diretamente a tabela do enunciado. Em seguida, o testbench inicializa as entradas com zero e aguarda um pequeno atraso para evitar que a primeira amostragem coincida exatamente com o tempo zero da simulação, prática que ajuda a manter as formas de onda mais claras.

O núcleo do processo de verificação é um laço `for` que percorre os índices de 0 a 9. Para cada iteração, o testbench aplica `vec_in_5311[i]` às entradas `{h,g,f,e}`, aguarda `#10` unidades de tempo para permitir a propagação da lógica combinacional e então compara as saídas das três instâncias com o valor esperado `vec_exp_8421[i]`. As comparações utilizam o operador de coincidência exata `!==`, capaz de detectar diferenças mesmo quando há bits desconhecidos (`X`) ou de alta impedância (`Z`). Sempre que uma discrepância é encontrada, o testbench incrementa um contador de erros e imprime uma mensagem detalhada com o índice, o valor de entrada e as saídas incorretas.

Além da verificação numérica, o testbench também gera um arquivo de formas de onda por meio das chamadas `$dumpfile("wave.vcd")` e `$dumpvars(0, tb_conver)`. Isso permite analisar, em ferramentas como GTKWave, a transição dos sinais ao longo do tempo, a coerência entre as três implementações e possíveis glitches transitórios. Ao final do laço, um bloco de decisão avalia o contador de erros: se for zero, é impressa uma mensagem de sucesso indicando que todas as implementações estão consistentes; caso contrário, o número de falhas é reportado. Por fim, a simulação é encerrada explicitamente com `$finish`, acompanhado da mensagem “Fim da simulacao.”. Essa metodologia garante reprodutibilidade, clareza e facilidade de extensão, bastando adicionar novos vetores de teste ou novas instâncias de módulos se necessário.

## 5.4 Aplicações Práticas e Extensões Possíveis

Conversores de código como o desenvolvido neste projeto têm diversas aplicações práticas em sistemas digitais reais. Um cenário clássico envolve interfaces entre **dispositivos legados** e **novos módulos** que adotam diferentes convenções de codificação. Por exemplo, imagine um painel de controle industrial antigo que emprega BCD 5311 em seus sensores e teclados, enquanto um módulo de processamento moderno, implementado em FPGA, espera receber os dados em formato 8421 para alimentar um decodificador de display de sete segmentos padrão. Inserir o conversor 5311‑>8421 como bloco intermediário permite manter a retrocompatibilidade sem redesenhar o hardware legado. Em um sistema desse tipo, cada dígito lido do teclado passaria por um conversor semelhante ao `conver_structural` e, na sequência, seria encaminhado para um driver de display ou para lógica aritmética em 8421.

Outra aplicação interessante está em **sistemas embarcados didáticos**, nos quais se deseja demonstrar a equivalência funcional entre diferentes códigos ponderados. Em laboratórios de arquitetura de computadores ou de eletrônica digital, o conversor pode ser utilizado como exercício prático para que alunos explorem mapas de Karnaugh, derivem equações booleanas, implementem módulos com portas básicas e comparem as sínteses geradas pelas três abordagens (behavioral, dataflow e structural). Ao sintetizar o mesmo projeto em diferentes FPGAs, é possível medir o impacto da descrição HDL no número de LUTs, níveis de lógica e margem de timing, o que gera discussões relevantes sobre otimização de hardware.

Do ponto de vista de extensões, uma possibilidade é transformar o bloco atual em um **módulo parametrizável** dentro de um sistema maior de entrada e saída, incluindo registradores de captura, multiplexadores e lógica de verificação de erro. Também é possível combinar o conversor com detecção de códigos inválidos em 5311, gerando um sinal de erro quando a entrada não corresponder a nenhum dígito decimal, o que aumentaria a robustez do sistema em cenários com ruído ou falhas de comunicação. Outra extensão prática seria integrar o conversor em um **barramento de comunicação** que envia dígitos decimal‑codificados entre diferentes placas, utilizando 5311 em um lado e 8421 em outro. Em aplicações de sistemas de medição, como instrumentação industrial ou equipamentos laboratoriais, essa flexibilidade de recodificação simplifica a integração de módulos de fornecedores distintos. Em todos esses casos, a separação em três abordagens de implementação mantém o valor didático do projeto, permitindo que a mesma funcionalidade seja redescrita em níveis crescentes de abstração e detalhamento.
