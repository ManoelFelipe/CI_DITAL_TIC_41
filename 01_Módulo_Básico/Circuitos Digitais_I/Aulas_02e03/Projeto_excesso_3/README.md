# Conversor BCD 8421 para Excesso-3 — Projeto_excesso_3

## 5.1 Descricao do Projeto

Autor: **Manoel Furtado**  
Data: **15/11/2025**

Este projeto implementa um conversor combinacional entre dois codigos decimais muito utilizados em sistemas digitais: o BCD 8421 e o codigo Excesso-3. A entrada do bloco e formada por um vetor de 4 bits que representa digitos decimais de 0 a 9 utilizando pesos 8-4-2-1 (bits A, B, C e D). A saida tambem e um vetor de 4 bits, porem codificado em Excesso-3, isto e, o valor decimal e incrementado de tres unidades antes de ser representado em binario. Dessa forma, o digito 0 em BCD torna-se 3 (0011) em Excesso-3, o digito 1 torna-se 4 (0100) e assim sucessivamente ate o digito 9, que se torna 12 (1100). Entradas de 10 a 15 sao tratadas como valores invalidos de BCD e sao mapeadas para um padrao neutro de 0000 apenas para evitar a propagacao de valores indefinidos em simulacao.

A arquitetura proposta mantem uma interface simples, com um unico barramento de entrada e um unico barramento de saida, permitindo que o mesmo testbench seja reutilizado para todas as abordagens de implementacao. Nao ha registradores internos nem logica sequencial, logo o bloco e puramente combinacional e apresenta latencia de um unico estagio de portas logicas. Isso o torna adequado para integracao em caminhos de dados rapidos em FPGAs ou ASICs, bem como em processadores e unidades aritmeticas que utilizem conversoes entre codigos decimais.

O projeto foi organizado em pastas separadas para uso em Quartus e Questa, respeitando um fluxo de trabalho profissional: os arquivos RTL de cada abordagem ficam centralizados na pasta `Quartus/rtl`, enquanto a estrutura de simulacao (RTL, testbench e scripts `.do`) permanece na pasta `Questa`. Essa separacao estimula boas praticas de engenharia, facilitando o reaproveitamento dos mesmos modulos em diferentes ambientes de desenvolvimento e em outros projetos que exijam conversao BCD para Excesso-3.

---

## 5.2 Analise das Abordagens (Behavioral, Dataflow e Structural)

A implementacao **Behavioral** foi pensada como a forma mais direta de descrever o conversor do ponto de vista funcional. O codigo utiliza um unico bloco `always @*` com uma instrucao `case` que percorre todos os valores validos de BCD (0 a 9) e associa explicitamente cada entrada ao codigo Excesso-3 correspondente. Essa abordagem reflete quase literalmente a tabela verdade e costuma ser a mais simples de entender para iniciantes, pois basta seguir o enunciado e replicar os pares de entrada e saida. Em termos de sintese, ferramentas de FPGA transformam essa descricao em uma combinacao de LUTs ou portas logicas equivalente, normalmente com boa otimizacao automatica. O principal cuidado nessa abordagem e garantir um caso `default` para evitar a inferencia de latches e definir um comportamento claro para entradas invalidas (10 a 15), o que foi feito mapeando-as para 0000.

Na implementacao **Dataflow**, o foco passa a ser a expressao explicita das equacoes booleanas minimizadas para cada bit da saida. A partir da tabela verdade e considerando 10 a 15 como condicoes de nao importacao (`dont care`), e possivel aplicar mapas de Karnaugh ou ferramentas de algebra booleana para chegar a equacoes mais compactas. O resultado foram quatro expressoes: `y0 = ~D`, `y1 = (C & D) | (~C & ~D)` (XNOR de C e D), `y2 = (~B & (C | D)) | (B & ~C & ~D)` e `y3 = A | (B & C) | (B & D)`. Em Verilog, essas equacoes sao expressas com atribuicoes `assign`, tornando o codigo altamente declarativo e naturalmente alinhado ao estilo de fluxo de dados. Essa abordagem permite visualizar melhor a estrutura logica interna e, em alguns casos, pode facilitar raciocinios de otimizaçao manual ou insercao de restricoes de temporizacao, ja que o projetista enxerga mais claramente em quantos niveis de portas cada bit da saida e calculado.

A abordagem **Structural** vai um passo alem e instancia explicitamente portas logicas primitivas (`and`, `or`, `not`). A mesma funcao de conversao e obtida, mas agora o caminho de dados e descrito como uma rede de sinais intermediarios e operacoes elementares. Cada produto e soma de termos da forma normal soma de produtos e realizada com combinacoes de portas simples, o que reproduz de maneira quase direta o resultado de uma implementacao em logica discreta com circuitos integrados TTL ou CMOS. Essa forma de descricao e especialmente util em ambientes didaticos, pois permite que estudantes visualizem como equacoes booleanas se desdobram em uma rede de portas fisicas. Em termos de sintese, a ferramenta normalmente reconhece essas portas e volta a mapeia-las em LUTs ou portas internas do dispositivo, mas o projetista mantem controle fino sobre a granularidade das operacoes, o que pode ser relevante em otimizacoes de area ou consumo em implementacoes muito especificas.

Comparando as tres abordagens, a versao behavioral e a mais concisa e menos suscetivel a erros de algebra, sendo ideal para prototipagem rapida. A versao dataflow oferece um equilibrio interessante entre legibilidade e transparencia da logica interna, sendo adequada quando se deseja alinhar o codigo a resultados de minimizacao manual. Ja a versao structural e a mais verbosa, mas a que melhor espelha a realidade fisica da implementacao, sendo indicada em contextos educacionais, de verificacao formal da estrutura, ou quando e necessario forcar estilos especificos de mapeamento de portas.

---

## 5.3 Descricao do Testbench e Metodologia de Simulacao

O testbench `tb_excesso_3.v` foi projetado para ser **auto-verificante** e, ao mesmo tempo, simples o suficiente para ser facilmente entendido e adaptado a outros projetos de conversao de codigo. A ideia central e ter um unico gerador de estimulos que alimenta simultaneamente as tres abordagens do conversor (behavioral, dataflow e structural), comparando as saidas com um valor de referencia calculado internamente. Para isso, o testbench declara um registrador `bcd_in` que representa a entrada BCD 8421 e tres vetores de fios correspondentes a cada implementacao. Em seguida, sao instanciados os tres DUTs, conectando `bcd_in` na entrada e ligando cada saida a seu respectivo fio de monitoramento.

A geracao de estimulos e feita em um bloco `initial` com um loop `for` que percorre todos os valores possiveis de 0 a 15. A cada iteracao, o testbench atribui o valor do indice `i` ao registrador `bcd_in`, aguarda um atraso de `#10` ns para garantir a propagacao dos sinais combinacionais e, em seguida, calcula o valor de Excesso-3 esperado para aquela entrada. Esse calculo e encapsulado em uma funcao `expected_excess_3`, que implementa a mesma tabela verdade do projeto, retornando os valores corretos para entradas entre 0 e 9 e um padrao neutro para entradas invalidas (10 a 15). Ao centralizar a logica de referencia em uma funcao, evitamos duplicar a tabela em varios pontos do testbench, reduzindo o risco de inconsistencias.

Depois de calcular o valor esperado, o testbench compara os sinais de saida de cada implementacao com a referencia, usando operadores de comparacao de igualdade exata (`!==`) para capturar eventuais `X` ou `Z` indevidos. Se qualquer uma das implementacoes divergir, o testbench incrementa um contador de erros e imprime uma mensagem detalhada contendo o valor de entrada, o valor esperado e as tres saidas observadas. Caso contrario, exibe uma mensagem de "OK" que confirma a consistencia das abordagens para aquele digito. No final do loop, um resumo e impresso: se `error_count` for zero, e exibida uma mensagem de sucesso indicando que todas as implementacoes sao consistentes para BCD de 0 a 9; caso contrario, informa o numero total de falhas encontradas.

Para auxiliar na analise de formas de onda, o testbench contem um segundo bloco `initial` responsavel por habilitar o `dumpfile` e o `dumpvars`, gerando um arquivo `wave.vcd`. Esse arquivo pode ser aberto em visualizadores como GTKWave ou mesmo em interfaces integradas do Questa, permitindo observar a evolucao temporizada de `bcd_in` e das tres saidas ao longo da simulacao. Essa combinacao de verificacao automatica com inspeçao visual e bastante poderosa: o projetista consegue detectar rapidamente falhas logicas e, em paralelo, entender o comportamento dinamico do circuito ao longo do tempo. Alem disso, o testbench foi escrito de forma deterministica e sem esperas infinitas, terminando explicitamente com `$finish`, o que evita loops travados e facilita a integracao com scripts de simulacao em linha de comando.

---

## 5.4 Aplicacoes Praticas e Contexto em Sistemas Digitais

Conversores entre codigos decimais sao blocos fundamentais em uma grande variedade de sistemas digitais, especialmente em dispositivos que precisam interagir com seres humanos ou com outros sistemas legados que utilizam representacoes decimais compactadas. O codigo Excesso-3, em particular, e conhecido por suas propriedades de **autocomplementaridade**: o complemento de nove de um digito decimal pode ser obtido simplesmente invertendo todos os bits de sua representacao em Excesso-3. Isso simplifica de maneira significativa a implementacao de certas operacoes aritmeticas, como subtracao por complemento de base em somadores binarios, reduzindo a necessidade de circuitos dedicados a geracao de complemento. Dessa forma, um conversor BCD -> Excesso-3 como o desenvolvido neste projeto pode ser usado na entrada de unidades aritmeticas decimais para facilitar algoritmos de subtracao, comparacao ou normalizacao.

Em processadores ou DSPs que implementam instrucoes de aritmetica decimal, e comum que os dados sejam armazenados internamente em formatos compactados, mas precisem ser convertidos para codigos mais convenientes durante as operacoes internas. Um caminho de dados pode, por exemplo, receber valores em BCD 8421 oriundos de um barramento externo, converte-los para Excesso-3 para executar somas e subtracoes de forma mais eficiente, e posteriormente reconverter os resultados para BCD tradicional antes de grava-los na memoria ou exibi-los em um display de sete segmentos. Nesses cenarios, ter uma biblioteca bem testada de conversores como o `excesso_3` reduz o tempo de desenvolvimento e aumenta a confiabilidade, pois a logica de conversao passa a ser reutilizada em varios modulos sem necessidade de reimplementacao.

Em ambientes educacionais, o circuito tambem tem papel importante. A partir de um exemplo relativamente simples como a conversao BCD 8421 -> Excesso-3, estudantes podem praticar todo o ciclo de projeto digital: derivar tabelas verdade, aplicar mapas de Karnaugh, deduzir equacoes minimizadas, implementar as equacoes em diferentes estilos de HDL (behavioral, dataflow, structural), criar testbenches auto-verificantes e analisar formas de onda em simuladores. Essa experiencia oferece uma visao completa do fluxo de desenvolvimento, muito semelhante ao que e encontrado em projetos industriais mais complexos, mas com uma complexidade logica ainda gerenciavel em sala de aula.

Outra aplicacao pratica relevante surge em sistemas embarcados que realizam contabilizacao, medidas ou faturamento em que a base decimal precisa ser preservada ate os niveis finais de apresentacao. Imagine, por exemplo, um medidor de energia ou um terminal de ponto de venda que precisa executar operacoes aritmeticas sobre valores monetarios mas, ao mesmo tempo, manter compatibilidade com modulos de display e protocolos legados de comunicacao baseados em BCD. A conversao temporaria para Excesso-3 pode permitir a reutilizacao de blocos aritmeticos comuns de soma binaria, evitando a necessidade de projetar hardware decimal dedicado. Em FPGAs modernos, isso pode significar economia de LUTs e registradores, alem de maior facilidade para cumprir restricoes de temporizacao, ja que boa parte do suporte do fabricante e otimizada para operaçoes puramente binarias.

Por fim, o projeto tambem ilustra boas praticas de organizacao de arquivos e de integracao entre ferramentas de sintese (Quartus) e simulacao (Questa). Ao manter as tres abordagens implementadas, documentadas e verificadas pelo mesmo testbench, criamos um exemplo concreto de como estruturar uma pequena biblioteca de conversores reutilizaveis. Em um projeto maior, o mesmo padrao poderia ser seguido para outros conversores de codigo (por exemplo, BCD 5311, Gray, 7-segmentos), compondo um conjunto modular de IPs internos que aceleram o desenvolvimento de sistemas digitais voltados a processamento de informacoes decimais.

