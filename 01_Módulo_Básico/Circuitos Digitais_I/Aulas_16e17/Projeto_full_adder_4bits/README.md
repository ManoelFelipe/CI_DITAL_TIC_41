# Projeto – Somador Parametrizável de 4 bits (`full_adder_4bits`)

**Autor:** Manoel Furtado  
**Data:** 11/11/2025

## 5.1 Descrição do Projeto
Este projeto implementa um somador binário parametrizável cujo caso base é a largura de 4 bits, em conformidade com o exercício proposto. O bloco recebe dois vetores `A` e `B` e um `Cin` e devolve o vetor de soma `S` e o `Cout`. A solução foi escrita em Verilog‑2001 para compatibilidade com Quartus e Questa e disponibilizada em três estilos de descrição: **Behavioral**, **Dataflow** e **Structural**. A arquitetura adotada é de **ripple‑carry**, em que o carry se propaga sequencialmente do bit menos significativo ao mais significativo. Embora simples, essa topologia é didaticamente adequada para visualizar o efeito do carry e comparar estilos de descrição. O módulo é **parametrizável** por `N` (default 4), permitindo sintetizar larguras diferentes sem alterar a interface. Os arquivos foram organizados em pastas separando as três versões e fornecemos um **testbench autochecado** que varre exaustivamente os 512 vetores possíveis para `N=4`. Scripts `.do` para o Questa automatizam a limpeza, compilação e execução, escolhendo qual implementação será simulada. O foco do projeto é demonstrar, sob o mesmo comportamento funcional, as diferenças práticas entre modos de escrita que o engenheiro encontra na indústria: expressividade (behavioral), concisão (dataflow) e controle fino de estrutura (structural).

## 5.2 Análise das Abordagens
**Behavioral.** A versão comportamental encapsula a operação de soma em um bloco combinacional `always @*` e utiliza um registrador temporário `resultado` de `N+1` bits para receber o valor aritmético completo de `A + B + Cin`. Na sequência, o código fatia explicitamente o vetor para atribuir `S = resultado[N-1:0]` e `Cout = resultado[N]`. Esse estilo é particularmente útil quando a lógica precisa de passos intermediários, saturações, flags ou *post‑processing* (por exemplo, *overflow* assinado). Em termos de síntese, ferramentas modernas reconhecem a operação aritmética e inferem somadores padrão. O custo temporal cresce linearmente com `N` quando a tecnologia não aplica *retiming* ou *carry‑chains* específicas. Em FPGAs, o mapeamento usa *carry chains* dedicadas, reduzindo atraso e área. A legibilidade é alta e a depuração no *waveform* é simples porque os sinais intermediários ficam explícitos.

**Dataflow.** A versão de fluxo de dados utiliza uma única atribuição contínua `assign {cout, s} = a + b + cin;`. É a forma mais concisa e, muitas vezes, a mais próxima do que a ferramenta espera para inferir os recursos nativos de soma. Por evitar blocos procedurais, elimina riscos de *latch* acidental e reduz *boilerplate*. Em contrapartida, quando o projeto exige instrumentação, arredondamentos ou políticas de saturação, a expressão única tende a ficar densa, dificultando comentários linha a linha e a inspeção de etapas. Em desempenho e área, a síntese é equivalente à behavioral, pois ambas descrevem a mesma operação combinacional. A vantagem concreta está na manutenção para blocos pequenos e bem definidos; a desvantagem surge quando o escopo cresce e a legibilidade do “único assign” degrada.

**Structural.** A versão estrutural instancia `N` somadores completos de 1 bit (módulo `full_adder_1bit`) conectados por um barramento de *carry* `c`. O laço `generate` materializa explicitamente a topologia *ripple‑carry*. Esse estilo é ideal para ensino de arquitetura e para casos em que o projetista deseja injetar variantes por estágio (por exemplo, substituir os dois estágios mais significativos por *carry‑lookahead* ou inserir *pipeline* seletivo). O custo é a verbosidade e a propensão a erros de conexão; por isso, comentários e nomeação cuidadosa dos sinais são essenciais. Do ponto de vista de síntese, a ferramenta preserva a conectividade e mapeia cada 1‑bit adder nas *carry chains* do dispositivo, alcançando desempenho similar às demais versões. Em ASICs, a hierarquia pode facilitar *floorplanning* e *place&route* dirigidos.

## 5.3 Metodologia do Testbench
O testbench foi concebido como **autochecado** e **exaustivo** para `N=4`. Ele instancia o DUT parametrizado e executa três laços aninhados: `ia` varre `A` de 0 a 15, `ib` varre `B` de 0 a 15 e `icin` alterna `Cin` entre 0 e 1, totalizando **512 vetores**. Para cada combinação, os sinais de entrada são aplicados, aguarda‑se um pequeno atraso (#1) para estabilização combinacional e calcula‑se o valor esperado com aritmética inteira: `esperado = ia + ib + icin`. A checagem compara o vetor `{cout, s}` ao valor `esperado[N:0]` usando igualdade case‑inequívoca (`!==`) para denunciar ‘X/Z’. Em caso de falha, o banco imprime um relatório detalhado com tempo, valores decimais e hexadecimais, o resultado obtido e o esperado. Ao final, a *flag* `erros` determina o status: zero erros implicam aprovação de todos os vetores; caso contrário, é exibido o número de falhas. Para suporte a análise de formas de onda, o bloco `initial` gera **VCD** via `$dumpfile`/`$dumpvars`, possibilitando inspeção no GTKWave ou no ModelSim/Questa (conversão automática). O *testbench* evita práticas que induzem *latches*, não usa *force* e não depende de *clock*, uma vez que o DUT é puramente combinacional. Como boas práticas adicionais, parametrizamos `N` localmente para facilitar reuso; garantimos que o DUT tenha o mesmo nome nos três estilos para que o mesmo testbench sirva a todas as variações; e utilizamos atrasos curtos para acelerar a simulação sem mascarar condições de corrida. Em síntese, a metodologia assegura cobertura completa do *input space* para o caso de 4 bits, promovendo **reprodutibilidade** e **diagnóstico imediato**.

## 5.4 Aplicações Práticas
Somadores parametrizáveis são blocos onipresentes em datapaths digitais: ALUs de microcontroladores, acumuladores de filtros FIR, geração de endereços em controladores de memória e normalização em unidades de ponto‑flutuante. Em FPGAs, o mapeamento nas *carry chains* embutidas permite que um somador de 32 ou 64 bits atinja centenas de MHz mesmo com a topologia *ripple*. Em ASICs, variações estruturais—como *carry‑lookahead*, *carry‑select* e prefixados (Kogge‑Stone, Brent‑Kung)—otimizam a latência em detrimento de área e roteamento. O módulo aqui proposto, por ser parametrizável (`N`), encaixa‑se em pipelines de diferentes larguras sem reformulação do código: por exemplo, um somador de 12 bits pode compor o acumulador de um ADC, enquanto um de 24 bits é comum em áudio digital. A versão **structural** é ponto de partida para estudos comparativos: trocar alguns estágios por *carry‑skip* possibilita medir ganhos de tempo em dados com baixa densidade de bits setados; ou inserir *pipeline* no meio do *ripple* para dobrar a frequência à custa de latência. A versão **behavioral** facilita experimentar políticas de saturação (clipping) em aritmética fixa, úteis em DSPs para evitar *wrap‑around*. Já a **dataflow** é adequada quando o bloco é simples e isolado, reduzindo risco de bugs. Em termos de riscos de síntese, é crucial manter larguras coerentes e evitar truncamentos silenciosos; por isso, adotamos vetores `N+1` na validação e comentários linha a linha para documentação formal. Ao transportar o módulo para sistemas maiores, recomenda‑se registrar entradas/saídas (uma batida de *clock*) quando o caminho crítico se tornar limitante—como em somadores de 64 bits combinacionais integrados a multiplicadores ou comparadores—seguindo a filosofia de *timing‑closure* incremental.
