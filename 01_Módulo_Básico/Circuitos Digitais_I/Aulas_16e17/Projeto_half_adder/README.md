# Projeto: Meio-Somador (Half Adder) — Três Abordagens de RTL e Testbench Autochecado

**Autor:** Manoel Furtado  
**Data:** 11/11/2025  

## 5.1 Descrição do Projeto
Este projeto implementa e compara diferentes formas de descrever um **meio‑somador** (half adder) de 1 bit em Verilog 2001. As entradas `A` e `B` são bits independentes, e as saídas são `Sum` (XOR lógico) e `Carry` (AND lógico). Foram produzidas três abordagens principais — **Behavioral**, **Dataflow** e **Structural** — com duas variantes comportamentais para ilustrar estilos equivalentes de síntese. O repositório inclui uma árvore de diretórios separando arquivos para **Quartus** e **Questa**, **scripts** `.do` para limpeza/compilação/execução e um **testbench autochecado** que instancia simultaneamente as quatro versões de RTL (duas comportamentais, uma de fluxo de dados e uma estrutural). O teste percorre todas as combinações possíveis de entradas (00, 01, 10, 11), compara cada saída com a referência calculada no próprio TB e relata **PASS/FAIL**. O objetivo didático é mostrar como descrições distintas convergem na mesma rede lógica (1 XOR + 1 AND) e como estruturar um pequeno projeto com **automatização de simulação** e **rastreabilidade de resultados** via VCD.

## 5.2 Análise das Abordagens
**Behavioral (always @\*) — variante 1.** Nesta forma, as saídas são declaradas como `reg` e atualizadas dentro de um bloco combinacional. O código explicita as expressões `sum_o = a ^ b;` e `carry_o = a & b;`. Em síntese, o mapeamento gera uma XOR e uma AND. A vantagem é a **clareza quando houver lógica condicional** ou agrupamento de atribuições; também facilita inserir comentários passo a passo e instrumentar lógica temporária. Risco comum: substituir `always @*` por um sensivity list incompleto ou usar atribuições bloqueantes em lógica sequencial; aqui é combinacional e está correto. Em projetos maiores, manter as saídas como `reg` pode gerar dúvidas para iniciantes, mas a semântica é puramente combinacional por causa do `@*`.

**Behavioral com operador de soma — variante 2.** A segunda versão usa `{carry,sum} = a + b;`. Síntese reconhece a equivalência com `XOR/AND` e produz o mesmo hardware. Ponto positivo: **conciso** e demonstra como a **aritmética de 1 bit** se relaciona com a lógica booleana. Ponto de atenção: alguns alunos confundem essa técnica e tentam generalizar para somadores de múltiplos bits esperando carry‑in automático; isso não ocorre sem declarar entradas adicionais ou largura maior. Em verificação, comparar as duas versões evidencia que estilos aritméticos e booleanos convergem.

**Dataflow (assign).** Esta abordagem usa apenas **atribuições contínuas**. É excelente para **documentar equações canônicas** e permite que a ferramenta faça **otimizações algébricas** triviais. O risco clássico é esquecer a direção do fluxo (assign para `wire`) ou misturar `reg` e `wire` de forma inconsistente. Em termos de portabilidade, é geralmente a forma mais clara e universal para lógica combinacional estática.

**Structural (primitivas).** Aqui, instanciamos explicitamente `xor` e `and`. A vantagem é a **transparência estrutural**, útil em aulas de portas e hierarquia. Em contrapartida, a escalabilidade é limitada; descrever funções maiores com portas primitivas aumenta o **boilerplate** e a suscetibilidade a erros de cabeamento. Ainda assim, para um módulo pequeno como o half adder, é uma forma valiosa de reforçar a equivalência lógica das demais descrições.

Em síntese comparativa: todas as abordagens geram a mesma microarquitetura (1 XOR, 1 AND, latência 0). Behavioral oferece flexibilidade para crescer, Dataflow maximiza legibilidade algébrica e Structural deixa explícitos os blocos físicos. A escolha depende do contexto: ensino de portas (Structural), documentação de fórmulas (Dataflow) ou integração em designs maiores (Behavioral).

## 5.3 Descrição do Testbench
O testbench `tb_half_adder.v` foi projetado como **autochecado** e **determinístico**. Ele declara `a` e `b` como `reg` e conecta esses sinais simultaneamente a quatro **DUTs** (Devices Under Test): `half_adder_beh` (behavioral com `always @*`), `half_adder_beh_sumop` (behavioral com operador `+` e concatenação), `half_adder_dataflow` (atribuições contínuas) e `half_adder_struct` (primitivas). A geração de estímulos usa um **laço `for`** que percorre `vec = 0..3`, aplicando `{a,b} = vec[1:0]` e um `#5` de atraso para acomodar a propagação combinacional. Em seguida, o TB calcula a referência **internamente** por `exp_sum = a ^ b` e `exp_carry = a & b`, eliminando dependência de arquivos externos de golden‑model. Para cada vetor, há uma comparação **bit a bit** de todas as saídas, e o TB acumula contadores `pass_count` e `fail_count`, além de uma **flag** `success`. Mensagens detalhadas de erro incluem o vetor, entradas, valores esperados e observados por implementação, reduzindo o tempo de depuração.

O TB também gera **VCD** por meio de `$dumpfile/$dumpvars`, permitindo a inspeção de formas de onda em GTKWave/Questa. As mensagens padronizadas (`OK`, `ERRO`, `RESULTADO`) asseguram rastreabilidade em CI. Como boas práticas, o TB evita `X/Z` em comparações (usa `!==`/`===` quando apropriado; aqui, `!==` detecta indefinições) e garante **encerramento limpo** com `$finish`. Potenciais armadilhas evitadas: esquecimento de inicializar `a` e `b`, latches acidentais (inexistentes, pois a DUT é combinacional), e erros de conectividade (validados por instâncias paralelas). Em projetos maiores, essa estrutura permite extensão imediata para **cobertura funcional**, geração aleatória de estímulos e inclusão de **asserts** (ainda dentro do Verilog 2001, via `if/$display`).

## 5.4 Aplicações Práticas
O meio‑somador é bloco didático, mas sua relevância prática é ampla. Em **somadores completos** (full adders), o half adder compõe etapas internas quando se particiona a lógica em soma sem carry‑in e propagação separada. Em **árvores de redução** (ex.: Wallace, Dadda, CSA), células equivalentes a meio‑somadores realizam compressão de colunas onde não há carry‑in, reduzindo a altura da árvore. Em **processadores**, a unidade lógica‑aritmética (ALU) pode reutilizar a rede XOR/AND para operações de paridade e detecção de colisões de bits. Em **caminhos de dados** de criptografia e codificação, half adders surgem no nivelamento de latências de pipelines onde a soma parcial não exige entrada de transporte. Num cenário ilustrativo, suponha multiplicação parcial de dois vetores de 8 bits: muitas colunas extremas do somatório possuem apenas dois bits — nelas, inserir um half adder em vez de um full adder reduz área e pode aliviar **timing**. Em FPGAs, sintetizadores normalmente mapeiam o XOR/AND de um half adder em **LUTs** simples com baixo **fan‑out**, o que contribui para frequência de operação maior quando comparado a uma cascata de full adders desnecessários. Em ASICs, a biblioteca padrão frequentemente inclui **células HA** específicas, otimizadas para consumo dinâmico e drive. Boas práticas incluem: (i) preservar a natureza **combinacional** (sem registradores ocultos); (ii) separar a descrição do half adder da lógica de controle; (iii) parametrizar a largura ao generalizar para vetores multibit; e (iv) adotar testbenches autochecados como o presente, que escalam naturalmente para regressões maiores e integração contínua.

