
# Projeto – Carry Look-Ahead Adder 4 bits (CLA-4)

**Autor:** Manoel Furtado  
**Data:** 11/11/2025

## 5.1 Descrição do Projeto
Este repositório implementa um somador do tipo *Carry Look‑Ahead* (CLA) com largura de 4 bits em três níveis de abstração Verilog: **Behavioral**, **Dataflow** e **Structural**. O bloco recebe operandos `A[3:0]`, `B[3:0]` e `C_in`, produzindo `Sum[3:0]` e `C_out`. A arquitetura aplica os conceitos clássicos de **propagação** `P=A⊕B` e **geração** `G=A∧B` para antecipar os *carries* `C1..C3` e `Cout` por meio de expressões de paralelismo lógico, reduzindo a profundidade de portas do caminho crítico quando comparado a um *ripple-carry adder*.  
O projeto foi estruturado para compilar tanto no **Quartus** quanto no **Questa** (ModelSim Intel). Em `Questa/scripts/` há *scripts* `.do` para limpeza, compilação e execução em GUI/CLI, permitindo alternar a implementação por meio da variável `IMPLEMENTATION` no `compile.do`. O **testbench** realiza uma bateria de testes dirigida e uma varredura exaustiva (512 casos), emitindo VCD para inspeção de ondas e um relatório de sucesso/erros ao final. Todos os arquivos `.v` incluem cabeçalho padronizado e comentários linha a linha, conforme o enunciado.

## 5.2 Análise das Abordagens
**Behavioral.** A versão comportamental encapsula toda a lógica combinacional em um único bloco `always @(*)`. Os vetores `p` e `g` são computados por operações bit‑a‑bit (`^` e `&`), e os *carries* são obtidos usando as fórmulas canônicas do CLA: `C1=G0+P0C0`, `C2=G1+P1G0+P1P0C0` e `C3=G2+P2G1+P2P1G0+P2P1P0C0`. A vantagem desta abordagem é a **clareza semântica** e a menor verbosidade, favorecendo manutenção e revisão rápida. Em síntese lógica, ferramentas modernas inferem portas com profundidade equivalente à forma de dados, de modo que o atraso crítico é dominado pelas cadeias OR com *fan‑in* moderado. Como não há registradores, a latência é de 0 ciclos; o tempo de *setup* é determinado pelas árvores lógicas. Em termos de **área**, a expansão das expressões introduz alguns termos redundantes, mas a otimização booleana do sintetizador costuma reduzir a contagem de portas às *implicants* essenciais. Um cuidado é evitar atribuições parciais que possam inferir *latches*. Outro ponto é manter o vetor de *carries* alinhado ao índice do bit somado (`sum = p ^ c`), o que previne erros de deslocamento.

**Dataflow.** Aqui, a descrição usa apenas `assign` contínuos. Os sinais `p` e `g` são declarados como *wires* e as equações dos *carries* são explicitadas em *signals* nomeados (`c1`, `c2`, `c3`). Essa forma é **ideal para verificação formal** e instrumentação, pois cada equação é observável e pode ser alvo de *asserts* e *cover*. Em síntese, a ferramenta reconhece diretamente a estrutura de prefixo, podendo reestruturar as árvores de portas para metas de *timing* (por exemplo, balanceando ORs para reduzir o *skew* lógico). O custo de área é similar ao *behavioral*, mas a legibilidade de dependências melhora. Em projetos maiores, essa abordagem facilita o *pipelining* seletivo (basta registrar `c1..c3` e `sum`) quando a frequência alvo cresce; no nosso projeto a latência permanece combinacional. Riscos comuns: esquecer algum termo de produtos (ex.: `P2P1P0C0`) altera `C3` e só aparece quando `(A,B,Cin)` ativam exatamente esse caminho; por isso o TB exaustivo é essencial.

**Structural.** A versão estrutural instancia primitivas `and`, `or` e `xor` correspondendo a cada implicante das equações do CLA. Ela é **útil para ensino e análise de atraso** porque torna explícito o grafo de portas e a contagem de níveis lógicos: para `Cout`, por exemplo, o caminho pior é `P3 · C3`, em que `C3` possui até três níveis adicionais de AND/OR. Em tecnologia ASIC/FPGA, essa forma tende a mapear de maneira previsível para *LUTs* com *fan‑in* limitado (4–6). Em FPGAs, as ferramentas podem colapsar *XOR/AND/OR* em LUTs únicas, e então tanto *behavioral* quanto *structural* chegam a implementações muito próximas. A desvantagem é a **verbosidade** e a suscetibilidade a erros de ligação; no entanto, quando se deseja criar variações (ex.: bloco gerador de *carries* compartilhado para 8/16 bits), esta base estrutural facilita o *reuse*. Boas práticas incluem nomear termos intermediários (`t30..t33`) segundo seu papel lógico, evitando colisões e mantendo coerência com documentos teóricos.

## 5.3 Metodologia do Testbench
O testbench foi projetado para fornecer **confiança total** sobre a correção funcional nas três variantes. Primeiro, são aplicados quatro casos dirigidos, equivalentes aos exemplos do enunciado, úteis para inspeção visual nas ondas e para garantir que conectividade e polaridades estão corretas. Em seguida, uma **varredura exaustiva** percorre todos os pares `(A,B)` no intervalo `0..15` e ambos os valores de `Cin`, totalizando **512** combinações. A cada estímulo, o TB espera um pequeno `#delay` para estabilização, calcula o valor de referência `ref = A + B + Cin` usando aritmética inteira de 5 bits, e compara bit a bit com `{Cout,Sum}` do DUT. Divergências são contabilizadas em um contador `errors` e registradas por `$display` com *timestamp* e vetores, o que facilita a análise de regressões. Para **observabilidade temporal**, o TB emite um arquivo **VCD** (`wave.vcd`) com todos os sinais hierárquicos, permitindo medir a ordem de ativação das redes CLA e localizar possíveis *hazards* (glitches) inerentes aos diferentes caminhos de propagação. A estrutura do TB é **determinística** e livre de `fork/join` ou *drivers* concorrentes, reduzindo o risco de *race conditions*. Como não há clock, o ambiente é puramente combinacional, o que simplifica a leitura das ondas e garante reprodutibilidade em qualquer simulador compatível com Verilog‑2001. Finalmente, as mensagens “SUCESSO” ou “FALHAS” oferecem um critério objetivo de aprovação, facilitando integração com *pipelines* de CI (por exemplo, executando `run_cli.do` com retorno de status a partir do padrão de texto).

## 5.4 Aplicações Práticas
Somadores CLA de 4 bits são amplamente empregados como **blocos básicos** em arquiteturas maiores. Em ALUs clássicas, um CLA‑4 é usado como célula em cascata sob um gerador de *carries* em árvore (ex.: Kogge‑Stone, Sklansky, Brent‑Kung) para formar somadores de 16/32/64 bits com bons compromissos de *timing*. Em **DSPs**, CLAs curtos são ideais para acumuladores e estágios de normalização em operações de ponto fixo e ponto flutuante (por exemplo, alinhar mantissas antes da adição IEEE‑754), onde o atraso do somador costuma dominar o caminho crítico. Em **FPGAs**, CLAs de pequena largura mapeiam eficientemente para *LUTs* e *carry chains* dedicadas; mesmo quando a família oferece *carry ripple* ultrarrápido, manter o cálculo paralelo de `C1..C3` ajuda a minimizar o *fan‑out* e balancear recursos. Uma aplicação pedagógica é a instrumentação de **verificação formal**: a abordagem *dataflow* expõe equações que podem receber *asserts* de equivalência entre `{Cout,Sum}` e `A+B+Cin`. Em **sistemas embarcados** que exigem metas de frequência moderadas (100–300 MHz em FPGAs médios), CLAs de 4/8 bits em mosaico oferecem boa previsibilidade sem consumir muita área. Boas práticas incluem: (i) encapsular o bloco em um módulo parametrizável e replicá‑lo para larguras maiores; (ii) considerar *pipelining* quando `Fmax` exigir, registrando `P/G` e *carries* em uma ou duas etapas; (iii) expor sinais `P` e `G` via portas opcionais para *debug*; e (iv) tratar *reset* apenas quando houver registros. Limitações: para larguras muito grandes, o número de termos em `Ck` cresce exponencialmente, tornando mais eficiente migrar para **prefix adders** com árvores balanceadas. Ainda assim, o CLA‑4 continua útil como **macro‑bloco reutilizável** e como referência de validação funcional em fluxos educacionais e industriais.
