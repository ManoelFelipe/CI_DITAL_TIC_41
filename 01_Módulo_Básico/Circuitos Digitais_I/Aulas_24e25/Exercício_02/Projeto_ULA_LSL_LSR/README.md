# Projeto ULA_LSL_LSR — ALU de 4 bits com operações de deslocamento lógico

## 5.1 Descrição do Projeto

Autor: **Manoel Furtado**  
Data: **11/11/2025**

Este projeto implementa uma Unidade Lógica e Aritmética (ULA) de 4 bits batizada de `ULA_LSL_LSR`, estendendo uma ULA básica que já realizava seis operações combinacionais clássicas (AND, OR, NOT(A), NAND, soma e subtração). A extensão proposta pelo exercício consiste em incluir duas novas operações de deslocamento lógico: **LSL (Logical Shift Left)** e **LSR (Logical Shift Right)**, ambas atuando exclusivamente sobre o operando A e deslocando-o em exatamente uma posição. Em LSL, o bit mais significativo é descartado e o menos significativo é preenchido com zero; em LSR, o bit menos significativo é descartado e o mais significativo é preenchido com zero. Dessa forma, garantimos um comportamento puramente lógico, sem preservação de sinal ou rotação de bits.

A interface da ULA foi mantida compatível com a versão anterior, utilizando operandos `A` e `B` de 4 bits, um seletor de operação de 3 bits (`seletor`) e uma saída de 4 bits (`resultado`). O mapeamento dos códigos de operação é o seguinte: `000` para AND, `001` para OR, `010` para NOT(A), `011` para NAND, `100` para A+B, `101` para A−B, `110` para LSL(A) e `111` para LSR(A). Essa escolha aproveita os dois códigos anteriormente não utilizados (110 e 111), mantendo compatibilidade com eventuais testbenches ou circuitos externos que já assumiam um seletor de 3 bits.

O projeto foi desenvolvido em três estilos de descrição em Verilog-2001: **behavioral**, **dataflow** e **structural**, todos puramente combinacionais e com latência zero. Para cada abordagem há um arquivo `ULA_LSL_LSR.v` separado nas pastas `behavioral`, `dataflow` e `structural` tanto na árvore de `Quartus` quanto na de `Questa`. A estrutura também inclui um testbench específico `tb_ULA_LSL_LSR.v` e scripts `.do` que automatizam limpeza, compilação e simulação no ambiente Questa, facilitando a reprodutibilidade e a análise das formas de onda geradas em `wave.vcd`.

## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

A implementação **behavioral** da `ULA_LSL_LSR` descreve a lógica da ULA por meio de um único bloco `always @(*)` contendo uma estrutura `case` sensível ao seletor. Nessa abordagem, cada código de operação é mapeado diretamente para uma expressão Verilog simples, como `A & B` para AND, `A | B` para OR, `~A` para NOT(A) e `A + B` ou `A - B` para operações aritméticas. Os deslocamentos lógicos LSL e LSR são implementados com operadores de concatenação, respectivamente `{A[2:0], 1'b0}` e `{1'b0, A[3:1]}`, o que torna explícito o descarte e o preenchimento dos bits extremo. Do ponto de vista de síntese, essa descrição é bastante amigável: a ferramenta infere automaticamente portas lógicas, somadores e multiplexadores equivalentes à descrição estrutural, mantendo boa legibilidade e baixo risco de latches acidentais graças ao uso do `default` no `case`. Uma atenção importante é garantir que a largura de todos os resultados seja consistente (4 bits), evitando extensões de sinal inesperadas.

Na versão **dataflow**, toda a lógica é expressa com atribuições contínuas (`assign`) e operadores aritméticos/lógicos. Cada operação primitiva é calculada em um wire separado, como `and_result`, `or_result`, `add_result` e assim por diante. Em seguida, um grande operador condicional ternário encadeado seleciona qual desses resultados será encaminhado à saída `resultado` em função do seletor. Essa abordagem enfatiza o fluxo de dados dentro do circuito: primeiro os valores intermediários são produzidos em paralelo, depois um multiplexador lógico escolhe o caminho apropriado. Em termos de desempenho, a síntese costuma gerar hardware equivalente ao da versão behavioral, mas o estilo dataflow facilita algumas otimizações manuais, como a reescrita de expressões combinacionais para reduzir a profundidade lógica ou o compartilhamento de subexpressões. O principal cuidado aqui é manter o encadeamento do ternário bem formatado para evitar erros de leitura, além de sempre definir um valor final padrão (no caso, `4'b0000`) para prevenir inferência de lógica indevida.

A implementação **structural** foca na decomposição explícita do circuito em blocos menores. São definidos módulos como `and4_block`, `or4_block`, `not4A_block`, `nand4_block`, `add4_block`, `sub4_block`, `lsl4_block` e `lsr4_block`, cada um responsável por uma função elementar de 4 bits. O módulo de topo instancia esses blocos e conecta suas saídas a um multiplexador `mux8_1_4bit`, que seleciona qual resultado será refletido em `resultado` com base no seletor. Essa abordagem espelha de forma clara a organização hierárquica do hardware, o que é especialmente útil em contextos didáticos e de verificação formal, pois permite testar isoladamente cada sub-bloco. A desvantagem é o aumento do número de arquivos ou de módulos em um mesmo arquivo, o que pode exigir maior disciplina de organização. Em termos de síntese, a estrutura resultante é muito transparente: a ferramenta reconstruirá uma rede de portas e multiplexadores praticamente idêntica ao diagrama que se desenharia em um software de captura esquemática.

## 5.3 Descrição Detalhada do Testbench e Metodologia de Simulação

O testbench `tb_ULA_LSL_LSR.v` foi projetado para validar de forma automatizada e exaustiva o comportamento da ULA nas três implementações. Ele instância um único módulo `ULA_LSL_LSR`, assumindo que os scripts de compilação escolhem qual versão (behavioral, dataflow ou structural) será usada em cada rodada de simulação. Os sinais de estímulo `A`, `B` e `seletor` são modelados como registradores (`reg`), enquanto a saída `resultado` é observada como um `wire` conectado à ULA. Além disso, o testbench mantém um registrador `esperado`, que guarda o resultado de referência, e um contador inteiro `erros`, responsável por contabilizar todas as discrepâncias encontradas.

A metodologia de simulação baseia-se em três conjuntos principais de vetores. No primeiro, são utilizados valores relativamente simples (`A = 0101`, `B = 0011`) e o testbench varre todos os oito códigos de operação, de `000` a `111`, com um atraso de 5 ns entre cada mudança de seletor. Para cada combinação, uma tarefa chamada `calcula_esperado` executa um modelo comportamental de referência, que repete em Verilog o mesmo mapeamento de operações da ULA: operações lógicas básicas, soma, subtração e deslocamentos LSL/LSR. Em seguida, a tarefa `show_vector` imprime no console o tempo de simulação, os operandos, o seletor e os valores de `resultado` e `esperado`. Se os dois valores não coincidirem (`resultado !== esperado`), o contador de erros é incrementado e uma mensagem de erro específica é exibida indicando o vetor e o seletor onde ocorreu a divergência.

O segundo conjunto de vetores utiliza operandos com bits mais significativos ativados (`A = 1101`, `B = 1010`), explorando cenários com possíveis estouros ou empréstimos nas operações aritméticas. Novamente, todos os códigos de operação são varridos em loop, garantindo que AND, OR, NOT, NAND, soma, subtração, LSL e LSR sejam exercitados em um contexto diferente do primeiro vetor. Por fim, o terceiro conjunto foca especificamente em padrões que evidenciam o comportamento dos deslocamentos lógicos. É utilizado `A = 1001`, onde tanto o MSB quanto o LSB são iguais a 1, para demonstrar claramente que o LSL descarta o MSB e insere um zero no LSB, enquanto o LSR descarta o LSB e introduz um zero no MSB. Para esses dois casos, o seletor é ajustado diretamente para `110` e `111` e o testbench realiza comparações dedicadas.

Ao final da simulação, o testbench avalia o contador `erros`. Se nenhum erro foi registrado, são impressas mensagens destacando que todos os testes passaram com sucesso. Caso contrário, o número total de falhas é reportado. Em qualquer cenário, uma mensagem de encerramento (“Fim da simulacao.”) é exibida e a chamada a `$finish` termina a simulação de forma limpa. Em paralelo, um bloco `initial` configura a geração de um arquivo `wave.vcd` com `$dumpfile` e `$dumpvars`, permitindo a visualização posterior das formas de onda em ferramentas como GTKWave. Essa combinação de checagem automática e inspeção gráfica torna o ambiente de verificação robusto e pedagogicamente rico, ajudando o estudante a correlacionar teoria, código e comportamento temporal do circuito sintetizado.

## 5.4 Aplicações Práticas e Boas Práticas de Projeto

Mesmo sendo uma ULA de apenas 4 bits, o módulo `ULA_LSL_LSR` captura princípios fundamentais de hardware digital aplicáveis em contextos reais. Operações lógicas básicas e aritméticas inteiras aparecem em praticamente qualquer microcontrolador, unidade de processamento ou bloco de controle discreto de FPGA. A inclusão explícita das operações de deslocamento lógico LSL e LSR aproxima ainda mais o projeto das unidades de execução encontradas em processadores reais, onde shifts são usados para tarefas como multiplicação e divisão por potências de dois, manipulação de campos de bits, alinhamento de dados e implementação eficiente de máscaras ou tabelas de lookup. Por exemplo, uma multiplicação por 2 de um número de 4 bits pode ser feita simplesmente com LSL, desde que o estouro seja aceitável, enquanto LSR é frequentemente utilizado para extrair bits mais significativos após etapas de filtragem ou conversão.

Em aplicações embarcadas, uma ULA compacta como esta pode ser utilizada como bloco de ensino em kits didáticos, como parte de um datapath acadêmico que inclui registradores, banco de registradores, contador de programa e unidade de controle microprogramada. Alunos podem estender o seletor com novos códigos para introduzir funções adicionais, como XOR, comparação de magnitude ou rotação circular, reaproveitando a estrutura de multiplexação já presente. Além disso, o fato de o projeto estar organizado em três estilos de descrição facilita experimentos de síntese: é possível comparar diretamente, em uma mesma FPGA, o uso de área e a frequência máxima obtida para as implementações behavioral, dataflow e structural, reforçando a percepção de que diferentes descrições em HDL podem resultar em hardware fisicamente equivalente.

Do ponto de vista de boas práticas de projeto, o módulo destaca a importância de manter interfaces estáveis (mesmos sinais e larguras), documentar explicitamente o mapeamento de opcodes e evitar comportamento indefinido com valores padrão bem definidos. A presença de comentários linha a linha, nomes em `snake_case` e cabeçalhos padronizados ajuda a manter a legibilidade em equipes maiores ou em projetos de longa duração. Já o testbench exemplifica uma estratégia moderna de verificação: ao invés de apenas observar formas de onda manualmente, ele incorpora um “modelo dourado” embarcado e efetua comparações automáticas, o que é essencial quando se passa de projetos de alguns bits para blocos mais complexos, como multiplicadores de ponto flutuante ou unidades de filtragem digital. Assim, este pequeno projeto de ULA serve não apenas como exercício de sintaxe Verilog, mas como um micro-laboratório de boas práticas em projeto e verificação de hardware digital.
