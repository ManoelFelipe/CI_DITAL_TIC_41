# Projeto ULA_LSL_LSR_mod — Unidade Lógica e Aritmética de 4 bits com LSL/LSR Variáveis

## 5.1 Descrição do Projeto

Autor: **Manoel Furtado**  
Data: **11/11/2025**  

Este projeto implementa uma Unidade Lógica e Aritmética (ULA) de 4 bits chamada `ULA_LSL_LSR_mod`, concebida para fins didáticos em disciplinas de Sistemas Digitais e Projeto de Circuitos Lógicos. A arquitetura foi desenhada para operar sobre dois operandos de 4 bits (`a_in` e `b_in`), controlados por um sinal de seleção de 3 bits (`op_sel`), totalizando oito operações combinacionais clássicas: AND, OR, NOT(A), NAND, soma, subtração e dois deslocamentos lógicos (LSL e LSR). O diferencial em relação ao exercício anterior é que, agora, o valor de deslocamento de LSL e LSR não é mais fixo em um bit; ele passa a ser determinado dinamicamente pelo operando B. Dessa forma, o mesmo bloco lógico é capaz de aplicar deslocamentos de 0 até 4 posições sobre o operando A, o que enriquece a exploração de casos de teste e o entendimento de saturação em circuitos de deslocamento.

Para manter a coerência com a largura de 4 bits, o fator de deslocamento é explicitamente saturado em 4 posições. Assim, qualquer valor de B maior que quatro é automaticamente mapeado para o valor 4, o que evita deslocamentos “excessivos” que tornariam a operação trivial (todos os bits em zero) ou poderiam confundir a análise do estudante. Essa saturação é importante didaticamente, porque obriga o aluno a pensar em limites de faixa e em como tratá-los de forma segura em hardware.

A ULA foi descrita em três estilos de abstração clássicos em Verilog: behavioral, dataflow e structural, todos compatíveis com o padrão Verilog-2001 e com os fluxos de síntese do Quartus e de simulação no Questa. O projeto inclui ainda um testbench auto-verificante (`tb_ULA_LSL_LSR_mod.v`) e scripts `.do` para automação completa da simulação, além deste README com discussão detalhada das abordagens, da metodologia de testes e de aplicações práticas do bloco em arquiteturas maiores.

## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

Na implementação **behavioral**, a ULA é descrita por um único bloco `always @(*)` que captura diretamente a intenção funcional do projetista. Dentro deste bloco, o fator de deslocamento é calculado a partir de `b_in` com uma lógica simples de saturação: se `b_in > 4`, então `shift_amt` recebe 4; caso contrário, recebe `b_in[2:0]`. Em seguida, uma estrutura `case` sobre `op_sel` define, de forma declarativa, qual operação será aplicada. Esse estilo é bastante próximo de uma especificação de alto nível: o projetista pensa na função e deixa ao sintetizador a responsabilidade de decompor a lógica em portas. Sua principal vantagem é a rapidez de desenvolvimento e a legibilidade, especialmente quando se deseja introduzir rapidamente novas operações ou alterar a semântica de comandos já existentes. Em contrapartida, o controle fino sobre a topologia do circuito fica restrito à habilidade do sintetizador, o que pode resultar em implementações ligeiramente diferentes em ferramentas distintas.

A abordagem **dataflow** migra parte dessa lógica para atribuições contínuas, enfatizando expressões de fluxo de dados. Cada operação elementar (AND, OR, NOT, NAND, soma, subtração, LSL, LSR) é descrita por um `assign` separado, e o resultado final é selecionado por uma cadeia de operadores condicionais ternários que formam um multiplexador lógico. O cálculo do fator de deslocamento também é feito com um `assign`, o que reforça a ideia de que tudo é estritamente combinacional e sem estados internos. Em termos de síntese, a diferença para o behavioral tende a ser pequena, mas o estilo dataflow ajuda o aluno a visualizar claramente como a função global se decompõe em blocos de dados interconectados. Esse tipo de descrição também é útil quando se quer mapear blocos diretamente em recursos dedicados do FPGA, como LUTs e carry chains, ainda que o controle de baixo nível continue nas mãos do sintetizador.

Por fim, a implementação **structural** materializa explicitamente essa decomposição em blocos menores. A ULA é composta por módulos elementares (`ula_and4`, `ula_or4`, `ula_not4`, `ula_add4`, `ula_sub4`, `ula_lsl4`, `ula_lsr4`, além de um saturador de deslocamento e de um multiplexador 8:1 de 4 bits). O módulo de topo instancia cada bloco e conecta todos por meio de sinais internos claramente nomeados. Essa forma de descrição é a mais próxima de um diagrama de blocos de hardware: o aluno consegue traçar, fio a fio, o caminho percorrido pelos dados desde a entrada até a saída. Em termos de riscos, o estilo estrutural é mais verboso e sujeito a erros de conexão ou de largura de barramento, mas é também o que oferece maior previsibilidade de síntese. Boas práticas incluem comentar cada instância, conferir sistematicamente larguras e garantir que o multiplexador final cubra todos os códigos de operação, evitando `latches` acidentais ou estados indefinidos.

## 5.3 Descrição do Testbench e Metodologia de Simulação

O testbench `tb_ULA_LSL_LSR_mod.v` segue uma abordagem auto-verificante, ou seja, ele mesmo calcula a resposta esperada para cada vetor de entrada e compara com a saída do DUT (Device Under Test). Logo no início, são declarados registradores para `a_in`, `b_in` e `op_sel`, além de um sinal `resultado_out` ligado à saída da ULA. Um registrador adicional `esperado` armazena o valor de referência, e um contador inteiro `erros` acumula o número de discrepâncias encontradas. A diretiva `` `timescale 1ns/1ps`` garante uma resolução temporal adequada para os atrasos artificiais usados na geração de estímulos, e um bloco `initial` dedicado configura a geração do arquivo `wave.vcd`, permitindo a inspeção gráfica das formas de onda em ferramentas como GTKWave ou o próprio viewer do Questa.

A lógica de verificação concentra-se na tarefa `calcula_esperado`. Ela replica, em código simples, o comportamento da ULA: primeiro, calcula o fator de deslocamento saturado exatamente como no DUT, depois aplica um `case` sobre `sel_ref` para determinar o resultado. É importante notar que essa tarefa não compartilha sinais internos com o DUT; ela utiliza cópias locais (`a_ref`, `b_ref`) e opera de forma independente. Com isso, minimiza-se o risco de “validar” o DUT contra ele mesmo. Outra tarefa, `show_vector`, imprime no console o vetor de teste corrente, exibindo tempo simulado, entradas, código de operação e os valores do DUT e do modelo de referência. Essa impressão é útil tanto para depuração manual, durante o desenvolvimento, quanto para documentação de relatórios.

O bloco `initial` principal realiza uma varredura exaustiva de todos os valores possíveis de A, B e op_sel (8 × 16 × 16 combinações). Para cada tripla de valores, o DUT é estimulado, um pequeno atraso `#2` permite a propagação dos sinais combinacionais, e em seguida `calcula_esperado` é chamada para gerar o resultado de referência. Se `resultado_out` divergir de `esperado`, o testbench incrementa o contador de erros e emite uma mensagem detalhada, facilitando a localização do problema. Ao término da varredura, dois vetores adicionais são aplicados para validar especificamente a saturação do deslocamento quando B assume valores grandes (por exemplo, 9 e 14). Por fim, o testbench imprime um resumo indicando se todos os testes passaram ou quantos erros foram encontrados, escreve a mensagem `"Fim da simulacao."` e chama `$finish` para encerrar a simulação de forma limpa, permitindo a execução em modo batch (`run_cli.do`) sem intervenção do usuário.

## 5.4 Aplicações Práticas e Exemplos de Uso

Embora o projeto tenha sido desenvolvido com foco didático, a ULA de 4 bits com deslocamento variável modela vários padrões encontrados em arquiteturas reais. Em um processador simples de 4 bits destinado a aplicações embarcadas de baixa complexidade, um bloco como `ULA_LSL_LSR_mod` poderia compor diretamente o caminho de dados principal do processador, realizando tanto operações aritméticas quanto lógicas controladas por um campo de opcode. O fato de os deslocamentos LSL e LSR serem parametrizados pelo operando B imita a semântica de muitas instruções de conjunto RISC, em que o valor de deslocamento é fornecido por um registrador ou imediato. Um exemplo concreto: suponha que `a_in = 4'b0001` (valor 1 em binário) e `b_in = 4'b0011` (3 em decimal). Com `op_sel = 3'b110`, o resultado será `0001 << 3 = 1000`, ideal para operações de escalonamento rápido por potências de dois, como multiplicar por 8 sem usar um somador dedicado.

Outra aplicação prática emerge na implementação de rotinas de mascaramento e extração de campos em protocolos simples. O deslocamento lógico à direita com saturação pode ser usado para alinhar bits de interesse na posição menos significativa antes de aplicar uma máscara AND. Por exemplo, imagine que determinado protocolo armazene um campo de 2 bits nas posições mais significativas de uma palavra de 4 bits. Usando `op_sel = 3'b111` (LSR) e escolhendo apropriadamente `b_in` como fator de deslocamento (limitado a 4), é possível trazer esse campo para as posições 1:0 e, depois, aplicar uma operação AND com `0003` para isolá-lo. Em contextos educacionais, esse tipo de exemplo ajuda o aluno a perceber que deslocamentos não são apenas operações de “empurrar zeros”, mas ferramentas poderosas de manipulação de dados.

A saturação em 4 deslocamentos também é relevante em termos de robustez. Em muitos sistemas, o valor que define o deslocamento pode vir de registradores sujeitos a ruído ou a estados não inicializados. Ao limitar a faixa efetiva de deslocamento, reduz-se a probabilidade de resultados extremos inesperados (como zerar sistematicamente todas as palavras por deslocar mais do que a largura do barramento). Em FPGAs, isso pode significar um controle mais previsível sobre o uso de LUTs e sobre a profundidade de lógica associada a multiplexadores de deslocamento. Finalmente, o fato de o projeto ter sido implementado em três abordagens favorece a reutilização: a versão behavioral é ideal para prototipagem rápida, a versão dataflow pode ser integrada em cadeias de processamento de dados com foco em legibilidade de expressões, e a versão structural é especialmente adequada para ensino de hierarquia de módulos, para estudos de temporização pós-síntese ou mesmo como base para extensões futuras, como inclusão de flags de carry, overflow ou zero.
