
# Projeto ULA_LSL_LSR_mod_2 — ULA de 4 bits com flags C, V, Z e N

## 5.1 Descrição do Projeto

Autor: Manoel Furtado  
Data: 15/11/2025  

O projeto **ULA_LSL_LSR_mod_2** implementa uma Unidade Lógica e Aritmética (ULA) combinacional de 4 bits com suporte a oito operações básicas e um conjunto de quatro flags clássicas de arquitetura: **C** (carry/borrow para aritmética sem sinal), **V** (overflow em complemento de dois), **Z** (resultado nulo) e **N** (bit de sinal). A interface é composta por dois operandos de 4 bits (`a_in` e `b_in`), um seletor de operação de 3 bits (`op_sel`) e um barramento de saída de 4 bits (`resultado_out`), acompanhado das quatro flags. As operações suportadas são: AND, OR, NOT de A, NAND, soma, subtração, deslocamento lógico à esquerda (LSL) e deslocamento lógico à direita (LSR), usando o operando `b_in` como fator de deslocamento.

Do ponto de vista de representação numérica, a ULA foi pensada para ser utilizada tanto em contexto de **aritmética sem sinal** quanto em **aritmética sinalizada em complemento de dois**. A flag **C** é coerente com a interpretação clássica de aritmética sem sinal: em somas, `C=1` indica transporte para fora dos 4 bits; em subtrações, a codificação é `C=0` para empréstimo, `C=1` para ausência de empréstimo, alinhando-se à convenção de várias arquiteturas de microcontroladores. Já a flag **V** é derivada apenas dos bits de sinal dos operandos e do resultado, sinalizando estouro no modelo de complemento de dois, ou seja, quando o bit mais significativo deixa de refletir corretamente o sinal matemático.

A largura de 4 bits foi escolhida para manter o projeto didático e facilmente exaustivo em simulação. Mesmo assim, toda a lógica foi construída de forma **escalável**, permitindo generalização futura para N bits com alterações mínimas. O deslocamento lógico utiliza saturação do fator em até 4 posições, evitando deslocamentos maiores que a largura do barramento e garantindo previsibilidade da síntese. O projeto é inteiramente combinacional, com latência de **zero ciclos de clock**, e foi escrito em Verilog 2001 com compatibilidade confirmada para fluxos baseados em **Quartus** e **Questa/ModelSim**.

## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

Na implementação **behavioral**, a ULA é descrita com um único bloco `always @*` controlado por um `case (op_sel)`. Essa abordagem enfatiza a clareza do fluxo de decisão, aproximando a descrição Verilog de um pseudocódigo em linguagem de alto nível. Para cada operação, o bloco atribui explicitamente o `resultado_out` e as flags **C** e **V**, enquanto as flags **Z** e **N** são calculadas de forma uniforme após o `case`, a partir do resultado final. Isso reduz a redundância de lógica e minimiza riscos de inconsistência entre operações. Além disso, o bloco inicia todas as saídas com valores padrão, evitando inferência de *latches*. Em síntese, a abordagem behavioral tende a gerar um circuito combinacional bastante semelhante àquele obtido pelas demais abordagens, mas com custo menor de manutenção, já que basta editar um único `case` para incluir novas operações.

Na abordagem **dataflow**, a ênfase está na decomposição da ULA em expressões contínuas (`assign`) e em um grande multiplexador de saída. Cada operação é construída separadamente em sinais intermediários (`res_and`, `res_or`, `res_add`, etc.) e o `resultado_out` é definido como uma combinação condicional desses sinais. As flags **C** e **V** são calculadas em caminhos de dados específicos para soma e subtração, enquanto **Z** e **N** dependem diretamente do barramento de saída. Esse estilo facilita o raciocínio de **propagação de sinais** e muitas ferramentas de síntese o exploram para realizar otimizações agressivas, como compartilhamento de lógica entre caminhos de dados. O risco principal está em cadeias muito profundas de operadores condicionais, que podem implicar multiplexadores grandes e aumento de atraso crítico; porém, em 4 bits, o impacto é desprezível, e o código deixa explícitas as dependências entre sinais.

A implementação **structural** leva o particionamento um passo além, decompondo a ULA em vários blocos reutilizáveis: `ula_logic_block`, `ula_adder_block`, `ula_subtractor_block`, `ula_shifter_block` e `ula_flag_zn_block`. Cada bloco encapsula uma função bem definida (por exemplo, o somador com geração de C e V) e é instanciado no módulo de topo. O resultado final é obtido conectando esses blocos via multiplexadores simples, descritos com atribuições contínuas. Essa abordagem é particularmente útil em projetos maiores, pois favorece **reuso de IP**, substituição de implementações internas (por exemplo, trocar o somador simples por um CLA ou prefixado) e testes unitários de cada componente em separado. Em termos de síntese, o resultado costuma ser muito parecido com o estilo dataflow, mas a modularização ajuda a controlar o crescimento de complexidade conforme se aumentam a largura de dados ou a quantidade de operações suportadas.

## 5.3 Descrição do Testbench e Metodologia de Simulação

O testbench `tb_ULA_LSL_LSR_mod_2` foi projetado para realizar uma verificação **exaustiva** da ULA em regime puramente combinacional. A estratégia consiste em varrer todas as combinações possíveis de `op_sel` (8 operações), `a_in` (16 valores de 4 bits) e `b_in` (16 valores), perfazendo um total de 8 × 16 × 16 = 2048 vetores de teste. Essa quantidade é suficientemente pequena para simulação rápida, mas cobre completamente o espaço de estados relevante para operandos de 4 bits. Em cada iteração dos três laços `for`, o testbench aplica um novo trio `(op_sel, a_in, b_in)`, aguarda um pequeno atraso (`#1`) apenas para modelar a propagação combinacional e, em seguida, chama a tarefa `calcula_referencia` para obter o **modelo ouro** do resultado e das flags.

A tarefa de referência implementa, dentro do testbench, a mesma lógica aritmética e de flags usada no projeto, mas de forma organizada e explícita, facilitando revisão e eventual alteração. Ela calcula somas e subtrações com largura estendida de 5 bits, detecta *carry* e *borrow* usando o bit mais significativo e deriva o overflow em complemento de dois apenas a partir dos bits de sinal, por meio das clássicas expressões de hardware. O fator de deslocamento para LSL/LSR é saturado em até quatro posições, garantindo coerência com o módulo DUT. Ao final, a tarefa calcula **Z** e **N** com base única no resultado de 4 bits, o que reforça a separação entre lógica aritmética e lógica de flags.

Após cada chamada à tarefa, o testbench compara, com operadores `!==`, o resultado e as quatro flags do DUT com os valores de referência. Em caso de discrepância, é impressa uma mensagem detalhando opcode, operandos, saídas observadas e saídas esperadas, o que facilita o *debug* de erros sutis, como inversão de sentido da flag C na subtração ou equívocos na condição de overflow. Um contador de erros é incrementado sempre que há divergência e, ao término da varredura, o testbench apresenta um resumo com o número total de vetores aplicados e de falhas encontradas. A inclusão do bloco de geração de VCD (`$dumpfile`/`$dumpvars`) permite inspecionar as formas de onda em viewers como GTKWave ou o próprio ModelSim, ajudando a visualizar, por exemplo, a correlação entre o bit de sinal do resultado e as flags **N** e **V**.

Do ponto de vista de boas práticas, o testbench evita *clocks* desnecessários em um circuito puramente combinacional, não utiliza tarefas de *reset* e não depende de inicialização implícita de registradores. Toda a lógica de verificação está concentrada em um único bloco `initial`, favorecendo a reprodutibilidade. Em tamanhos de palavra maiores, a varredura exaustiva passaria a ser inviável e seria necessário migrar para uma bateria pseudoaleatória de vetores, possivelmente com geração dirigida por cobertura funcional, mas para o caso de 4 bits a abordagem exaustiva garante confiança máxima na correção do DUT.

## 5.4 Aplicações Práticas e Extensões Possíveis

Embora o projeto ULA_LSL_LSR_mod_2 utilize apenas 4 bits, ele espelha, em miniatura, muitos conceitos presentes em unidades aritméticas reais de microprocessadores e microcontroladores. As quatro flags implementadas — **C, V, Z, N** — são praticamente onipresentes em arquiteturas como ARM, AVR, PIC e várias famílias de DSPs, e são fundamentais para a implementação de instruções de desvio condicional, normalização de resultados e tratamento de erros numéricos. Em um cenário prático, essa ULA poderia servir como núcleo de um **processador didático** de 4 bits, onde instruções como ADD, SUB, AND, OR, LSL e LSR são executadas diretamente por esse bloco, enquanto a lógica de controle apenas seleciona o `op_sel` apropriado e interpreta as flags para decidir o fluxo de execução.

Outra aplicação importante está em **caminhos de dados configuráveis** em FPGAs, onde pequenas ULAs parametrizáveis são combinadas para formar processadores *softcore* ou aceleradores de sinal. A mesma estrutura de 4 bits pode ser replicada e encadeada para compor ULAs de 8, 16 ou 32 bits, com lógica de propagação de carry adaptada (por exemplo, substituindo o somador simples por um carry-lookahead ou prefixado). A presença explícita de `shift_amt` saturado já antecipa requisitos encontrados em manipuladores de campos de bits e em rotinas de codificação e decodificação, onde deslocamentos exagerados podem gerar resultados indefinidos em hardware real se não forem tratados com cuidado.

Do ponto de vista de ensino, o projeto permite exercícios focados em **projeto de flags**, algo frequentemente negligenciado em exemplos simplificados. Estudantes podem, por exemplo, alterar a semântica da flag C para a subtração, adicionar uma flag de *paridade* ou criar instruções adicionais, como somas com *carry in* ou deslocamentos que capturam no C o último bit deslocado para fora. Em aplicações industriais, a mesma estrutura é a base de módulos de **comparação** (maior/menor/igual), geradores de endereços para pipelines e controladores de laços. Também é possível integrar a ULA a um pequeno **estado sequencial**, como uma máquina de estados que implementa um algoritmo de soma acumulada ou filtragem FIR de baixa ordem, utilizando a flag Z para interromper o processamento quando o acumulador retorna a zero.

Por fim, o projeto serve como ponto de partida para discussões sobre **riscos de síntese**: ao aumentar a largura de palavra e o número de operações, o multiplexador de seleção do resultado pode se tornar o novo caminho crítico do circuito, exigindo particionamento ou *pipelining* para atender a requisitos de *timing* mais agressivos. Da mesma forma, a replicação ingênua do somador simples em ULAs largas tende a consumir mais área e energia que arquiteturas prefixadas otimizadas. Assim, a ULA de 4 bits aqui apresentada, embora simples, oferece um laboratório completo para experimentação com diferentes topologias de somadores, políticas de flags e estratégias de otimização em ferramentas de síntese.

