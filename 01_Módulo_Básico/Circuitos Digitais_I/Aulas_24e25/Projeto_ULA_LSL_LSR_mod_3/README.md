# Projeto ULA_LSL_LSR_mod_3 — AND/OR/NOT/NAND/NOR/XOR, Soma, Subtração, LSL e LSR

## 5.1 Descrição do Projeto

Autor: **Manoel Furtado**  
Data: **15/11/2025**

O projeto ULA_LSL_LSR_mod_3 implementa uma Unidade Lógica e Aritmética (ULA) puramente combinacional de 4 bits, pensada para uso didático em disciplinas de Arquitetura de Computadores, Organização de Computadores e Projetos em HDL. A unidade trabalha com dois operandos de 4 bits (`a_in` e `b_in`) e uma palavra de seleção `op_sel` de 4 bits responsável por escolher uma dentre dez operações disponíveis: AND, OR, NOT, NAND, NOR, XOR, soma, subtração, deslocamento lógico à esquerda (LSL) e deslocamento lógico à direita (LSR). As oito primeiras operações da versão anterior foram preservadas com os mesmos códigos binários, e as operações NOR e XOR foram adicionadas nos códigos `1000` e `1001`, respectivamente, mantendo compatibilidade com o testbench original ao mesmo tempo em que amplia as capacidades da ULA.

A interface é enriquecida com quatro flags de status: `flag_c` (carry/borrow), `flag_v` (overflow em complemento de dois), `flag_z` (resultado igual a zero) e `flag_n` (bit de sinal). Essas flags permitem que o mesmo bloco seja reutilizado tanto em contextos de aritmética sem sinal (onde `flag_c` é interpretado como carry-out) quanto em aritmética em complemento de dois (onde `flag_v` é o indicador de overflow). As duas operações de deslocamento utilizam um fator de deslocamento derivado de `b_in`, porém saturado em quatro posições, o que evita resultados não intuitivos se o campo de deslocamento for maior que a largura da palavra.

Do ponto de vista de síntese, a ULA_LSL_LSR_mod_3 foi projetada para ter latência combinacional única e não introduzir registradores internos. Isso facilita sua integração em datapaths pequenos ou em pipelines que utilizem estágios explícitos de registradores em módulos superiores. A presença de três estilos de descrição (behavioral, dataflow e structural) com a mesma interface facilita comparações diretas quanto a legibilidade, esforço de manutenção, inferência de hardware e resultados de temporização/área obtidos nas ferramentas de síntese.

---

## 5.2 Análise das Abordagens

A implementação **behavioral** descreve a ULA a partir de um único bloco `always @*`, onde toda a lógica é organizada em torno de uma instrução `case (op_sel)`. Esse estilo é o mais próximo da forma como se pensa o componente em alto nível: para cada código de operação, define-se diretamente o comportamento esperado. Por exemplo, a soma e a subtração utilizam registradores estendidos de 5 bits para capturar o carry ou borrow, e em seguida o resultado é truncado para 4 bits. As flags `flag_c` e `flag_v` são calculadas usando expressões booleanas explícitas sobre o bit de sinal das entradas e do resultado, respeitando as regras de overflow em complemento de dois. A grande vantagem dessa abordagem é a clareza: a leitura da tabela verdade da ULA é praticamente imediata, e ajustes pontuais (como inserir operações adicionais) são feitos com poucas linhas. Em contrapartida, o projetista depende fortemente do sintetizador para inferir a estrutura de hardware mais adequada, o que às vezes dificulta estimar o custo em área apenas pela leitura do código.

A implementação **dataflow** torna explícito o caminho de dados ao decompor a ULA em expressões intermediárias, cada uma representando o resultado de uma operação específica (por exemplo, `res_and`, `res_or`, `res_add`, `res_sub`, `res_lsl`, `res_lsr`, `res_nor` e `res_xor`). O resultado final é selecionado por uma cadeia de operadores ternários baseada em `op_sel`, que, em síntese, se transforma em um multiplexador de 10 entradas. As flags aritméticas (`flag_c` e `flag_v`) são calculadas usando também operadores contínuos, isolando o trecho de lógica responsável pela soma e pela subtração. Esse estilo facilita a análise qualitativa do hardware inferido: é intuitivo perceber que o sintetizador produzirá uma rede combinacional com múltiplas unidades em paralelo e um grande multiplexador de saída. Em termos de temporização, sabe-se de antemão que o caminho crítico passa pelo bloco aritmético (somador/subtrator) seguido do multiplexador.

Já a implementação **structural** vai além e descreve explicitamente o componente como a interconexão de blocos menores: portas lógicas de 4 bits (`and4`, `or4`, `nand4`, `nor4`, `xor4`), um inversor vetorial (`not4`), um somador de 4 bits (`adder4`), um subtrator de 4 bits (`sub4`) e unidades de deslocamento (`lsl4` e `lsr4`). Cada bloco é descrito com poucas linhas e pode ser reutilizado em outros projetos. O módulo principal ULA_LSL_LSR_mod_3, nessa abordagem, transforma-se em um diagrama de blocos: todas as operações são calculadas em paralelo, e um bloco `always @*` final atua como multiplexador e gerador das flags. A vantagem desse estilo é o controle fino sobre a granularidade do projeto: é possível, por exemplo, mapear cada submódulo em recursos específicos da FPGA (LUTs, slices, carry-chains) ou até substituí-los por IP cores otimizados. Em contrapartida, o volume de código é maior, e a manutenção exige mais disciplina, pois qualquer alteração funcional precisa ser propagada para vários arquivos ou submódulos.

Em resumo, a abordagem behavioral privilegia rapidez de escrita e legibilidade, a dataflow facilita a visualização do caminho de dados e do multiplexador final, e a estrutural fornece o maior controle sobre a topologia de hardware, sendo mais adequada quando se deseja otimizar manualmente área e timing em projetos de maior porte.

---

## 5.3 Descrição do Testbench

O testbench `tb_ULA_LSL_LSR_mod_3` foi concebido para realizar uma varredura exaustiva sobre o espaço de entrada da ULA. São percorridos todos os 16 valores possíveis para `op_sel` (0 a 15), todas as combinações de operandos `a_in` e `b_in` de 0 a 15 e, para cada tripla `(op_sel, a, b)`, o testbench compara o comportamento do DUT (Device Under Test) com um modelo de referência puramente comportamental implementado em uma `task` chamada `calcula_referencia`. Mesmo que apenas dez códigos de operação sejam utilizados pela ULA, os códigos restantes são tratados pelo modelo como operações nulas, o que ajuda a evidenciar se algum comportamento indesejado foi inferido para opcodes não mapeados.

Dentro da `task`, o fator de deslocamento é calculado a partir de `b_val` com saturação em quatro posições, reproduzindo a lógica interna da ULA. Em seguida, um `case (op_val)` implementa a função de referência para cada operação: AND, OR, NOT, NAND, soma, subtração, LSL, LSR, NOR e XOR. As operações aritméticas utilizam registradores estendidos de 5 bits para capturar o carry ou borrow e calcular as flags `c_ref` e `v_ref` de acordo com as regras de overflow em complemento de dois. Ao final, as flags `z_ref` e `n_ref` são derivadas diretamente do resultado: `z_ref` é 1 quando `res_ref` é zero, e `n_ref` corresponde ao bit mais significativo do resultado.

O bloco principal de estímulos utiliza três laços encadeados `for` para percorrer o espaço de entradas. Após aplicar um conjunto de valores, o testbench aguarda um pequeno atraso (`#1`) suficiente para permitir a propagação combinacional, chama a `task` de referência e incrementa o contador de vetores testados. Em seguida, compara resultado e flags do DUT com o modelo ouro usando operadores de igualdade estrita (`!==`) para capturar também estados indefinidos (`X`) ou de alta impedância (`Z`). Em caso de divergência, o testbench imprime uma mensagem detalhada com o opcode, os operandos, o resultado do DUT e o valor esperado, facilitando a depuração.

Ao término da varredura, o testbench apresenta um resumo com o número total de vetores aplicados e o número de erros observados. Se `erros` é igual a zero, uma mensagem informa que todos os testes passaram; caso contrário, sinaliza que há falhas a investigar. Além disso, a diretiva `$dumpfile("wave.vcd")` combinada com `$dumpvars(0, tb_ULA_LSL_LSR_mod_3)` permite visualizar, em ferramentas como GTKWave, todo o conjunto de sinais do testbench e do DUT, o que é extremamente útil para analisar o comportamento ciclo a ciclo, verificar o efeito das operações de deslocamento e estudar o impacto das operações NOR e XOR recém-adicionadas.

---

## 5.4 Aplicações Práticas

A ULA_LSL_LSR_mod_3, embora concebida como um exercício acadêmico, representa um bloco funcional bastante próximo do que se encontra em microcontroladores simples, processadores educacionais e unidades de processamento de sinais de pequena largura. Em uma CPU didática de 4 bits, este bloco poderia ser conectado diretamente ao banco de registradores, recebendo dois operandos internos e produzindo o resultado da operação aritmética ou lógica selecionada por um campo do opcode da instrução. As flags C, V, Z e N alimentariam um registrador de status, permitindo a implementação de instruções de desvio condicional, como "salte se zero", "salte se negativo" ou "salte se carry".

Em aplicações de processamento digital de sinais em baixa resolução, uma ULA com operações lógicas e aritméticas básicas é suficiente para implementar filtros simples, detectores de borda em imagens binarizadas e operações de máscara de bits. Por exemplo, a operação XOR pode ser usada para detectar transições em sinais digitais (comparando amostras consecutivas), enquanto as operações AND e OR permitem combinar múltiplos canais de controle. As operações de deslocamento lógico LSL e LSR são úteis para implementar multiplicações e divisões aproximadas por potências de dois, comuns em algoritmos que precisam ser implementados sem operadores de multiplicação/divisão explícitos para reduzir área de hardware.

Em ambientes de ensino, a coexistência das três abordagens (behavioral, dataflow e structural) dentro do mesmo projeto fornece um excelente laboratório para análise de síntese. O aluno pode sintetizar cada variante separadamente e comparar relatórios de utilização de recursos (número de LUTs, blocos de carry, níveis de lógica) e de temporização (atraso crítico máximo). É possível, por exemplo, verificar se a implementação estrutural que instancia explicitamente um somador de 4 bits consegue explorar melhor as cadeias de carry dedicadas de uma FPGA específica, reduzindo o atraso crítico quando comparada à versão puramente behavioral.

Finalmente, o projeto pode servir de base para extensões mais avançadas: aumentar a largura da palavra para 8, 16 ou 32 bits usando parâmetros (`parameter N=8`), incluir operações adicionais como comparação de magnitude, incremento/decremento, rotação de bits e operações lógicas condicionais, ou ainda integrar registradores de entrada e saída para pipeline, transformando a ULA em um estágio registrável dentro de um processador mais complexo. A presença das operações NOR e XOR já abre caminho para construir funções lógicas mais sofisticadas por combinação, e a estrutura modular do código facilita a expansão do conjunto de instruções e o reaproveitamento em outros projetos de sistemas digitais.
