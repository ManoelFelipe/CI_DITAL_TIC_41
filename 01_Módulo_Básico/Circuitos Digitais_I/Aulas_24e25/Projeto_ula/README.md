# Projeto ULA de 4 bits com 8 operacoes (resultado de 8 bits)

**Autor:** Manoel Furtado  
**Data:** 15/11/2025

---

## 5.1 Descricao do Projeto

Este projeto implementa uma Unidade Logica e Aritmetica (ULA) de 4 bits com oito operacoes combinacionais, adequada para uso didatico em disciplinas de Projeto Logico, Sistemas Digitais ou Arquitetura de Computadores. A ULA recebe dois operandos de 4 bits, `op_a` e `op_b`, um seletor de operacao de 3 bits e produz um resultado de 8 bits. As seis primeiras operacoes sao logicas e aritmeticas de baixa largura (AND, OR, NOT, NAND, soma e subtracao), originalmente pensadas para um barramento de saida de 4 bits. A extensao deste projeto adiciona duas novas operacoes — multiplicacao e divisao inteira — o que exige o aumento da largura do barramento de saida para 8 bits a fim de acomodar o produto completo 4x4 e a representacao conjunta de quociente e resto na divisao.

O mapeamento de operacoes segue uma codificacao simples e didatica: `000` para AND, `001` para OR, `010` para NOT de `op_a`, `011` para NAND, `100` para soma, `101` para subtracao, `110` para multiplicacao e `111` para divisao. Para as operacoes cujo resultado natural tem apenas 4 bits, a ULA aplica uma extensao de zeros (`zero-extend`) para alinhar o resultado no campo menos significativo do barramento de 8 bits. Na multiplicacao, o produto 4x4 e disponibilizado integralmente nos 8 bits de saida, sem truncamento. Na divisao inteira, foi adotada a convencao de compactar o resto nos 4 bits mais significativos (`resultado[7:4]`) e o quociente nos 4 bits menos significativos (`resultado[3:0]`).

O projeto e fornecido em tres estilos de descricao: **Behavioral**, **Dataflow** e **Structural**, organizados em diretorios separados para Quartus e Questa. Essa organizacao permite comparar diretamente como diferentes estilos de HDL impactam legibilidade, capacidade de reutilizacao e mapeamento sintetizado em hardware, mantendo o mesmo comportamento funcional. Um testbench auto-verificador exercita todo o espaco de entradas possiveis (operacoes, operandos e casos de divisao por zero) e assegura que todas as abordagens produzem exatamente o mesmo resultado, garantindo consistencia entre as implementacoes.

---

## 5.2 Analise das Abordagens

A implementacao **Behavioral** descreve a ULA em alto nivel a partir de um unico bloco `always @*` com uma estrutura `case` sobre o seletor de operacao. Cada operacao e codificada de maneira direta, manipulando os operandos `op_a` e `op_b` e atribuindo o resultado para um registrador combinacional de 8 bits. Esse estilo se aproxima da forma como um engenheiro de software pensaria o problema: ha uma lista de comandos if/else ou switch que escolhe qual calculo aplicar. A extensao de zeros para as operacoes de 4 bits e feita dentro de cada ramificacao, enquanto a multiplicacao e a divisao utilizam diretamente os operadores aritmeticos do Verilog (`*`, `/` e `%`), com um tratamento explicito para a divisao por zero. Do ponto de vista de sintese, o ferramental converte esse `case` em uma rede combinacional unica, sem latencia, que reflete a combinacao das operacoes logicas, aritmeticas e da multiplexacao da saida.

Na abordagem **Dataflow**, o foco e decompor o comportamento em expressoes que conectam fios (wires) e descrevem o fluxo de dados entre eles. Cada operacao e pre-calculada em um fio interno — por exemplo, `and_4`, `or_4`, `add_4` e `mul_8` — e, em seguida, sao construidos barramentos de 8 bits com extensao de zeros ou concatenacoes apropriadas. A divisao tambem e preparada com fios distintos para quociente e resto antes de serem compactados em um unico barramento de 8 bits. Por fim, um unico `assign` com operador ternario encadeado realiza a multiplexacao. Essa abordagem facilita o raciocinio em termos de blocos de transformacao de sinais e e particularmente util quando queremos inspecionar, em simulacao, os valores intermediarios das operacoes, pois cada fio interno aparece claramente nas formas de onda. Em termos de sintese, a estrutura resultante e semelhante a da versao behavioral, mas com a vantagem didatica de explicitar melhor o pipeline logico.

A implementacao **Structural** leva a decomposicao um passo adiante, instanciando modulos elementares para cada operacao e um multiplexador 8:1 de 8 bits. Blocos como `and4`, `or4`, `add4`, `mul4x4` e `div4x4` tornam-se unidades reutilizaveis que poderiam ser conectadas em outras arquiteturas mais complexas, como ALUs multi-palavra ou blocos de processamento vetorial. A divisao, por exemplo, e encapsulada em um modulo `div4x4` que produz o par `{resto, quociente}` em um unico barramento. A logica de selecao e delegada a um modulo `mux8_1_8bit` que recebe as oito possiveis operacoes (ja com largura ajustada) e entrega o resultado desejado. A abordagem estrutural destaca o paralelismo intrinseco do hardware: todas as operacoes sao calculadas em paralelo e apenas o multiplexador escolhe qual resultado sera exposto na saida. Em contrapartida, o codigo tende a ficar mais verboso e exige maior disciplina de organizacao de arquivos e instancias, embora reflita com mais fidelidade a realidade fisica do circuito sintetizado.

---

## 5.3 Descricao do Testbench

O testbench `tb_ula.v` foi projetado como um ambiente auto-verificador completo, capaz de validar simultaneamente as tres abordagens da ULA. Para isso, sao instanciados os modulos `ula_behavioral`, `ula_dataflow` e `ula_structural`, todos conectados aos mesmos sinais de estimulo: `op_a`, `op_b` e `seletor`. Cada uma das saidas e observada em fios distintos (`resultado_behavioral`, `resultado_dataflow` e `resultado_structural`), facilitando a comparacao direta em simulacao e em analises de formas de onda. Uma variavel interna `resultado_esperado` atua como modelo de referencia; ela e calculada a partir de uma logica `case` que replica exatamente as convencoes de extensao de largura, multiplicacao e divisao adotadas nos modulos de ULA. Dessa forma, o testbench nao apenas verifica se as implementacoes concordam entre si, mas tambem se estao coerentes com a especificacao funcional.

A geracao de estimulos explora integralmente o espaco de entrada atraves de tres lacos encaixados: `i` varia `op_a` de 0 a 15, `j` varia `op_b` de 0 a 15 e `k` percorre todos os codigos de operacao de 0 a 7. Para cada tripla `(op_a, op_b, seletor)`, o testbench aguarda um pequeno atraso (`#1`) para permitir a propagacao dos sinais e em seguida calcula o valor esperado. O caso especial de divisao por zero e tratado explicitamente, espelhando a convencao da ULA: quociente igual a zero e resto igual ao dividendo. Em seguida, o testbench compara o resultado esperado com as tres saidas. Caso alguma delas nao coincida, e incrementado um contador de erros e e emitida uma mensagem detalhada via `$display`, mostrando os valores de entrada, o resultado esperado e os resultados obtidos por cada implementacao. Ao final de todos os lacos, uma mensagem sintetiza o resultado da verificacao, informando se todas as implementacoes foram consistentes ou quantas divergencias foram detectadas.

Para auxiliar na analise visual, o testbench configura a geracao de um arquivo de ondas VCD por meio das chamadas `$dumpfile` e `$dumpvars`. Isso permite abrir a simulacao em ferramentas como GTKWave e inspecionar tanto as entradas quanto as saidas e sinais intermediarios. Em cenarios didaticos, o aluno pode, por exemplo, congelar a simulacao em uma operacao especifica de multiplicacao ou divisao e observar como cada abordagem se comporta. Esse tipo de verificacao e especialmente util quando se deseja demonstrar os efeitos de erros propositalmente introduzidos, como alterar a ordem de concatenacao de resto e quociente ou remover o tratamento de divisao por zero. O encerramento da simulacao e feito de maneira limpa com `$finish`, apos a impressao de uma mensagem final que indica o termino do processo de verificacao.

---

## 5.4 Aplicacoes Praticas

Embora este projeto tenha um forte carater didatico, a arquitetura de ULA de 4 bits com oito operacoes possui diversas aplicacoes praticas em sistemas digitais reais, principalmente como bloco basico em estruturas maiores. Em microcontroladores simples, blocos de ULA similares sao usados para executar instrucoes aritmeticas e logicas em registradores internos. Em vez de 4 bits, muitas arquiteturas operam com 8, 16 ou 32 bits, mas a ideia fundamental e a mesma: duas entradas de dados, um seletor de operacao e um barramento de saida. A presenca da multiplicacao e da divisao eleva o nivel da ULA em relacao a exercicios mais simples, aproximando-se de conjuntos de instrucoes reais encontrados em processadores de uso geral. Por exemplo, uma ALU de 8 bits poderia reutilizar a logica aqui modelada como bloco elementar, trabalhando com dois ciclos para processar operandos de 8 bits em fatias de 4 bits.

Em circuitos de controle embarcados, uma ULA desse tipo pode ser utilizada em modulos de calculo dedicados, como no ajuste de setpoints de sensores, calculo de medias ou operacoes de mascaramento de bits. A multiplicacao e a divisao, mesmo com operandos de apenas 4 bits, permitem construir funcoes de escalonamento de intensidade de atuadores ou ajustes finos em conversoes de unidades. Em um sistema IoT, por exemplo, um microcontrolador de baixo custo pode receber dados brutos de sensores e delegar a um pequeno bloco de ULA combinacional a tarefa de calcular um valor ajustado de PWM a partir de fatores codificados em 4 bits, aproveitando a multiplicacao para aplicar ganhos e a divisao para normalizar valores.

Do ponto de vista educacional, a arquitetura apresentada e um excelente ponto de partida para explorar temas como extensao de sinais, representacao de numeros negativos (por exemplo, alterando a ULA para operar em complemento de dois), deteccao de overflow e implementacao de sinais de status, como flags de zero, carry e negative. A saida de 8 bits facilita exercicios de interpretacao de produto e divisao, alem de permitir a futura expansao do projeto para incluir operacoes adicionais, como deslocamentos logicos e aritmeticos ou operacoes de comparacao. Finalmente, a separacao em tres abordagens — behavioral, dataflow e structural — oferece ao aluno a oportunidade de entender como diferentes estilos de codificacao podem resultar no mesmo comportamento, mas com implicacoes distintas na reutilizacao, na legibilidade e, potencialmente, na otimizacao sintetizada pelo ferramental de EDA.

