# Projeto ULA_FULL — Suporte a Múltiplas Representações Numéricas

## 5.1 Descrição do Projeto

Autor: **Manoel Furtado**  
Data: **15/11/2025**

O projeto **ULA_FULL** implementa uma Unidade Lógica e Aritmética parametrizável, projetada para explorar, em um único bloco combinacional, diferentes representações numéricas típicas de sistemas digitais: inteiro sem sinal, inteiro com sinal em complemento de dois, sinal/magnitude, ponto fixo no formato Q e um mini–float simplificado. A largura padrão escolhida é de 8 bits, mas o módulo foi parametrizado via `parameter WIDTH` e `parameter FRAC`, permitindo que a mesma base seja reutilizada em arquiteturas maiores ou menores, bem como em cenários com quantidades distintas de bits fracionários para operações em ponto fixo. O objetivo central é oferecer uma ULA didática, suficientemente rica para discutir efeitos de overflow, saturação, sinal, magnitude e escalonamento, sem perder a compatibilidade com fluxos clássicos de síntese usando Quartus e simulação com Questa (Verilog‑2001).

Do ponto de vista funcional, a ULA_FULL implementa um conjunto de operações aritméticas e lógicas elementares controladas por `op_sel`: soma, subtração, multiplicação, operações bit a bit (AND, OR, XOR) e deslocamentos à esquerda e à direita (com variantes lógicas ou aritméticas, dependendo do modo numérico). Cada operação é interpretada de acordo com o campo `num_mode`, que define a semântica dos bits de entrada: por exemplo, em modo `000` os operandos são considerados inteiros sem sinal; em `001`, inteiros com sinal em complemento de dois; em `010`, sinal/magnitude; em `011`, ponto fixo Q com `FRAC` bits fracionários; e em `100`, mini–float simplificado com 1 bit de sinal, 3 bits de expoente e mantissa compactada.

Além do resultado, a ULA gera um conjunto de flags de status: `flag_overflow`, `flag_saturate`, `flag_zero`, `flag_negative` e `flag_carry`. Estas flags permitem analisar, durante a simulação, os efeitos de saturação em operações que excedem o intervalo representável, bem como distinguir entre overflows em aritmética com sinal e em operações sem sinal. A presença destas flags torna o projeto particularmente útil em contextos de ensino, onde se deseja observar na prática os impactos de diferentes representações numéricas em operações aparentemente idênticas. Finalmente, o projeto foi estruturado em três abordagens (Behavioral, Dataflow e Structural), mantendo a mesma interface externa, o que facilita comparações diretas de síntese, leitura de código e depuração.

---

## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

A implementação **Behavioral** da ULA_FULL foi concebida como a referência funcional principal. Nela, utiliza‑se um único bloco `always @*` com um `case` externo baseado em `num_mode` e um `case` interno baseado em `op_sel`. Essa abordagem permite descrever explicitamente, linha a linha, o significado de cada operação para cada representação numérica, centralizando o raciocínio e facilitando a leitura didática. Por exemplo, na soma com sinal em complemento de dois (`num_mode = 3'b001`), os operandos são convertidos para versões estendidas com sinal (`ext_signed_a`, `ext_signed_b`), somados e, em seguida, verifica‑se overflow pela comparação entre os bits de sinal estendidos. Quando o overflow é detectado, ativa‑se a flag de saturação e o resultado é “clipado” para o extremo positivo ou negativo representável. Em operações de ponto fixo (`num_mode = 3'b011`), a multiplicação é realizada em largura dupla e o resultado escalonado via deslocamento dos bits intermediários, o que simula o comportamento típico de um formato Q com `FRAC` bits fracionários. O estilo behavioral favorece clareza, mas pode gerar lógica mais densa, dependendo da forma como o sintetizador otimiza os `case` aninhados.

A implementação **Dataflow** reorganiza a mesma lógica em uma função combinacional pura (`ula_core`) chamada a partir de atribuições contínuas. Em vez de um `always`, utiliza‑se uma função que recebe os operandos, a operação e o modo numérico, e devolve um vetor empacotado contendo resultado e flags. Internamente, a estrutura de `case` é mantida, mas o estilo incentiva a fatoração em expressões e wires intermediários, aproximando o código de um “esquema lógico” textual. Essa abordagem facilita a reutilização da função em diferentes contextos e deixa explícito que não há estados armazenados: trata‑se de uma ULA puramente combinacional. Do ponto de vista de síntese, espera‑se área e timing equivalentes ou muito próximos da versão behavioral, já que ambas acabam sendo reduzidas a redes combinacionais equivalentes. Em contrapartida, a depuração pode exigir atenção adicional ao vetor empacotado e ao mapeamento de bits de flags, mas o ganho pedagógico é a clareza na separação entre interface (assigns) e núcleo combinacional (função).

Por fim, a implementação **Structural** compõe o sistema a partir de submódulos: um pré‑adaptador de modo (`ula_mode_pre`), um núcleo aritmético (`ula_core_arith`) e um pós‑adaptador de saída (`ula_mode_post`). Nessa versão, o núcleo aritmético é implementado instanciando diretamente a ULA behavioral como bloco interno, mas a arquitetura foi pensada para permitir, futuramente, a substituição do núcleo por outra implementação (por exemplo, uma ULA pipelined ou especializada em erro reduzido). O valor pedagógico desta abordagem está em mostrar como encapsular e hierarquizar componentes: mesmo que, atualmente, os adaptadores apenas façam pass‑through, eles representam pontos claros de extensão para normalização de operandos, ajustes de escala, empacotamento de mantissas, etc. Em termos de síntese, a estrutura hierárquica tende a produzir resultados semelhantes aos da versão behavioral, mas a divisão em módulos auxilia no fechamento de timing em projetos maiores, permitindo aplicar constraints e floorplanning em blocos específicos, quando necessário.

---

## 5.3 Descrição do Testbench e Metodologia de Simulação

O testbench `tb_ula_full` foi estruturado para validar simultaneamente as três abordagens da ULA_FULL, garantindo consistência funcional entre elas para um conjunto representativo de casos de teste. A arquitetura do testbench instância, lado a lado, os módulos `ula_full_behavioral`, `ula_full_dataflow` e `ula_full_structural`, todos alimentados pelas mesmas entradas `op_a`, `op_b`, `op_sel` e `num_mode`. Dessa forma, cada vetor de estímulos produz três conjuntos de saídas e flags, que são comparados automaticamente. Esse arranjo espelha a estratégia comum em projetos maiores, em que se testa a equivalência de diferentes implementações de um mesmo bloco (por exemplo, uma versão de referência versus uma versão otimizada ou pipelined).

A geração de estímulos é organizada em loops aninhados. O loop mais externo percorre os modos numéricos de 0 a 4 (inteiro sem sinal, complemento de dois, sinal/magnitude, ponto fixo Q e mini–float simplificado). Em seguida, um segundo loop percorre os códigos de operação de 0 a 7, cobrindo soma, subtração, multiplicação, operações lógicas e deslocamentos. Por fim, dois loops internos percorrem subconjuntos dos operandos `op_a` e `op_b` de 0 a 15. Essa restrição intencional (em vez de varrer todo o espaço de 8 bits) mantém a simulação leve e rápida, ao mesmo tempo em que exercita, para cada modo e operação, uma gama de combinações que incluem zeros, valores pequenos e variações de sinais. Cada iteração dos loops incrementa um contador de testes e, após um pequeno atraso (`#1`), o testbench verifica se os resultados e flags retornados pelas três implementações são idênticos, utilizando comparações com `!==` para capturar também estados indefinidos.

Quando uma discrepância é detectada, o testbench imprime uma mensagem detalhada via `$display`, incluindo modo, operação, valores decimais de `op_a` e `op_b` e os resultados hexadecimais produzidos por cada implementação. Isso facilita a análise pontual de divergências nas formas de onda. Ao final da varredura, o testbench exibe um resumo indicando o número total de testes e o número de erros encontrados. Se `error_count` for zero, é exibida uma mensagem de sucesso (“Todas as implementações da ULA FULL estão consistentes”). Além disso, há um bloco responsável pela geração de `wave.vcd` por meio das chamadas `$dumpfile` e `$dumpvars`, permitindo que as formas de onda sejam abertas em ferramentas como GTKWave ou o próprio visualizador do Questa. A presença das flags de overflow, saturação, zero, negativo e carry como sinais monitorados permite ao projetista não apenas verificar a consistência entre implementações, mas também interpretar o impacto de cada modo numérico em operações específicas. Por exemplo, é possível observar exatamente em que combinação de `op_a`, `op_b`, `op_sel` e `num_mode` ocorre uma saturação em ponto fixo ou um overflow em complemento de dois. Essa metodologia, baseada em loops e checagem automática, reduz a necessidade de inspeção manual exaustiva e torna o testbench reutilizável em regressões futuras.

---

## 5.4 Aplicações Práticas e Situações Reais

A ULA_FULL com suporte a múltiplas representações numéricas tem aplicações práticas em diversos cenários de sistemas embarcados, processamento digital de sinais e arquiteturas educacionais de processadores. Em sistemas de controle embarcados, por exemplo, é comum empregar ponto fixo em formato Q para representar grandezas físicas (temperatura, velocidade, tensão) com precisão fracionária, mas sob restrições severas de hardware. Ao configurar a ULA_FULL para operar em modo `011` (ponto fixo Q) com um determinado número de bits fracionários (`FRAC`), pode‑se realizar somas, subtrações e multiplicações que representam, por exemplo, a atualização de um controlador proporcional‑integral (PI) ou a filtragem de sinais discretos. A flag de saturação permite detectar quando uma operação extrapolou o intervalo representável, algo crítico para evitar estouros que poderiam causar comportamentos instáveis em laços de controle.

Em aplicações de processamento de áudio ou vídeo em hardware, a distinção entre representações com sinal (complemento de dois, sinal/magnitude) e sem sinal é igualmente relevante. Imagine uma pipeline de processamento de imagem em que parte das operações trabalha com pixels em 8 bits sem sinal (0 a 255), enquanto outra etapa implementa filtros que produzem valores temporariamente negativos, mapeados em complemento de dois. A ULA_FULL pode ser configurada dinamicamente via `num_mode` para alternar entre estes contextos, permitindo que o mesmo bloco físico seja reutilizado em múltiplos estágios da pipeline. Além disso, o modo mini–float simplificado (`100`) é útil como protótipo para experimentos de quantização de redes neurais ou algoritmos de aprendizado de máquina em hardware, onde se deseja avaliar o impacto de formatos flutuantes reduzidos em precisão e saturação, sem implementar de imediato o conjunto completo de operações IEEE‑754.

Outra aplicação prática está em arquiteturas didáticas de processadores RISC‐like, usadas em disciplinas de Organização e Arquitetura de Computadores. A ULA_FULL pode ser integrada como bloco principal de execução de instruções aritméticas e lógicas, enquanto as flags de status se conectam a registradores de flags que alimentam unidades de decisão de salto condicional. Diferentes instruções poderiam configurar o `num_mode` para atuar com inteiros sem sinal em instruções de manipulação de endereços, e com inteiros com sinal em operações aritméticas. Em complemento, o mesmo bloco pode ser utilizado em um co–processador de DSP para executar operações em ponto fixo, demonstrando na prática como a escolha do formato numérico afeta tanto o resultado quanto a complexidade de hardware. Por fim, a própria estrutura tripla (Behavioral, Dataflow, Structural) e o testbench unificado tornam o projeto um estudo de caso completo para cursos de HDL avançado, em que os alunos podem comparar área, desempenho e legibilidade entre diferentes estilos de descrição, além de modificar parâmetros e modos para investigar novas representações numéricas ou faixas de saturação mais agressivas.
