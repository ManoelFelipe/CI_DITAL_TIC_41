# Projeto ULA_FULL com Divisão e Múltiplos Modos Numéricos

## 5.1 Descrição do Projeto

Autor: **Manoel Furtado**  
Data: **15/11/2025**

A ULA_FULL é uma Unidade Lógica e Aritmética projetada com foco didático e exploratório, mas com características suficientemente gerais para ser reutilizada em projetos maiores de arquitetura de processadores e sistemas embarcados em FPGA. O módulo foi concebido para operar sobre dois operandos de largura parametrizável (`WIDTH`, assumindo 8 bits neste experimento) e aceitar diferentes modos de interpretação numérica por meio do sinal `num_mode`. Dessa forma, um mesmo vetor de bits pode ser tratado como inteiro sem sinal (unsigned), inteiro com sinal em complemento de dois, valor em ponto fixo Q ou, em extensões futuras, mini‑float simplificado. Essa flexibilidade é essencial para disciplinas que discutem formatos numéricos e seus impactos na implementação em hardware.

Do ponto de vista funcional, a ULA suporta um conjunto de dezesseis operações selecionadas pelo campo `op_sel[3:0]`. Entre elas, destacam‑se soma, subtração, multiplicação, três variantes de divisão (unsigned, signed e Q), conjunto completo de operações lógicas (AND, OR, XOR, NAND, NOR, XNOR), deslocamentos lógicos e aritméticos, além de uma operação de comparação (CMP) que reutiliza a subtração para atualizar flags. As saídas incluem não apenas o resultado aritmético (`result`), mas também um conjunto de sinais de status: `flag_overflow`, `flag_saturate`, `flag_zero`, `flag_negative` e `flag_carry`. Esses sinais são importantes tanto para implementação de unidades de controle mais complexas quanto para fins pedagógicos, pois permitem discutir condições como overflow aritmético, saturação, resultado nulo, sinal do resultado e carry/borrow em operações inteiras.

A arquitetura do projeto foi organizada em três abordagens complementares — Behavioral, Dataflow e Structural — todas compatíveis com Verilog‑2001 e com a mesma interface externa. A intenção não é apenas comparar estilos de codificação, mas mostrar, de forma concreta, como diferentes descrições RTL podem resultar em circuitos equivalentes em síntese, embora com impactos distintos em legibilidade, modularização, capacidade de extensão e clareza na depuração. O projeto é acompanhado de um testbench unificado, `tb_ula_full`, que exerce as três implementações em paralelo e verifica automaticamente a consistência entre elas, tornando‑se um exemplo completo de fluxo de verificação em hardware digital.

---

## 5.2 Análise das Abordagens (Behavioral, Dataflow e Structural)

A implementação **Behavioral** da ULA_FULL foi escrita com um único bloco combinacional `always @*`, no qual todo o comportamento do módulo é descrito de forma sequencial e estruturada. Dentro desse bloco, são definidos valores‑padrão para o resultado e para todas as flags, o que evita a inferência de latches indesejados — uma boa prática essencial em projetos síncronos. Em seguida, um `case` externo sobre `num_mode` seleciona o modo numérico (por exemplo, unsigned, signed ou Q) e, dentro de cada modo, um `case` interno sobre `op_sel` define a operação a ser realizada. Esse arranjo permite que o leitor percorra a lógica quase como se estivesse lendo pseudocódigo: “se o modo é signed e a operação é SUB, então faça tal cálculo, atualize as flags e trate overflow dessa maneira”. Para fins didáticos, essa abordagem é particularmente clara, pois concentra em um único lugar todas as regras de negócio da ULA, incluindo conversões de tipo e decisões de saturação.

Do ponto de vista de síntese, o estilo behavioral tende a gerar um circuito combinacional equivalente ao que seria produzido por outras abordagens, desde que não sejam usados construtos temporais (como `#`) dentro do bloco. Entretanto, o fato de toda a lógica estar concentrada em um único `always` pode dificultar a manutenção à medida que novas operações são adicionadas. Um exemplo é a inclusão de operações mais complexas, como multiplicação acumuladora (MAC) ou funções transcendentes aproximadas: o bloco cresce, as estruturas de `case` ficam mais extensas e aumenta o risco de esquecer inicializações ou casos padrão. Em termos de timing, a ULA_FULL, por não ser pipelined, terá seu caminho crítico determinado principalmente por operações como multiplicação e divisão; em um FPGA real, uma divisão puramente combinacional pode comprometer a frequência máxima do projeto. Nesse caso, uma boa prática é registrar as saídas em estágios posteriores ou considerar versões iterativas/pipelined, independentemente da abordagem RTL utilizada. Ainda assim, a forma como o código behavioral está escrito facilita a inclusão posterior de registradores, pois a lógica combinacional já está bem isolada.

A abordagem **Dataflow** reorganiza a mesma lógica em uma função combinacional pura, normalmente declarada com `function automatic` em Verilog. Essa função recebe os operandos, o seletor de operação e o modo numérico, calcula o resultado e as flags em variáveis locais e retorna um vetor empacotado contendo todos esses sinais concatenados. No módulo principal, um `assign` contínuo chama a função e, em seguida, o vetor é “desempacotado” em `result` e flags individuais por meio de atribuições contínuas simples. Em termos de leitura, essa abordagem destaca a ULA como um “operador” combinacional bem definido, quase como uma função matemática de alto nível. Isso é útil para modularizar o código: o núcleo combinacional pode ser reutilizado em outros módulos, ou até instanciado múltiplas vezes com diferentes parâmetros de largura.

Comparando com a abordagem behavioral, a versão dataflow costuma produzir, após síntese, um circuito RTL essencialmente equivalente, já que os sintetizadores modernos tratam funções combinacionais como mero açúcar sintático. Entretanto, há vantagens práticas: o corpo do módulo fica mais enxuto, a interface fica visualmente destacada e é mais simples isolar o núcleo para testes unitários específicos. Em um cenário de risco de timing, por exemplo, o projetista pode decidir encapsular essa função em um módulo separado e adicionar registradores nas entradas e saídas sem alterar o restante do design. Em termos de área, não há diferença significativa entre behavioral e dataflow, desde que a lógica interna da função seja a mesma; o fator determinante continua sendo o uso de operadores de multiplicação e divisão e a largura dos operandos. Uma boa prática ao usar dataflow é documentar cuidadosamente o formato do vetor empacotado de saída (ordem de flags, posição do resultado), para evitar erros sutis ao desempacotar.

Por fim, a abordagem **Structural** explicita a hierarquia de módulos ao instanciar um núcleo combinacional reutilizável (por exemplo, `ula_full_core`) dentro de um wrapper estrutural (`ula_full_structural`). Nesse arranjo, o núcleo concentra toda a lógica aritmética e de geração de flags, enquanto o wrapper se limita a conectar portas e, potencialmente, inserir elementos adicionais como registradores, multiplexadores ou lógica de enable. Do ponto de vista didático, essa abordagem é valiosa para introduzir conceitos de hierarquia, reutilização de módulos e encapsulamento. Em projetos reais de processadores, é comum que a ALU seja apenas um bloco dentro de um pipeline mais complexo, que inclui unidades de busca de instrução, decodificador, registradores de propósito geral e estágios de memória e write‑back. A versão estrutural da ULA_FULL se aproxima desse estilo de organização, preparando o terreno para que o aluno enxergue a ULA como “mais um bloco” em uma arquitetura maior.

Em termos de síntese, a abordagem estrutural não necessariamente gera um circuito mais eficiente do que as outras duas, mas favorece a evolução incremental do design. Por exemplo, é relativamente simples substituir o núcleo combinacional por uma versão pipelined, mantendo a interface estável para o restante do sistema. Também é possível instanciar múltiplas ULAs em paralelo (por exemplo, para SIMD ou para uma unidade de execução superescalar) simplesmente replicando o módulo estrutural. Um risco comum nessa abordagem é a fragmentação excessiva da lógica em submódulos muito pequenos, o que pode atrapalhar a análise de timing e tornar mais difícil rastrear sinais em ferramentas de depuração. A boa prática é encontrar um equilíbrio entre granularidade e legibilidade: o núcleo deve ser suficientemente grande para encapsular uma funcionalidade significativa, mas não tão monolítico a ponto de inviabilizar a reutilização.

---

## 5.3 Descrição do Testbench e Metodologia de Simulação

O testbench `tb_ula_full` foi concebido para funcionar como um verificador automático de consistência entre as três abordagens da ULA_FULL. Em vez de testar cada implementação isoladamente, o testbench instancia simultaneamente as versões Behavioral, Dataflow e Structural, conectando‑as ao mesmo conjunto de sinais de entrada (`op_a`, `op_b`, `op_sel`, `num_mode`). Dessa forma, cada vetor de teste aplicado é avaliado em paralelo pelas três ULAs, e o próprio testbench compara os resultados e flags, sinalizando qualquer divergência. Este tipo de verificação cruzada é uma boa prática em projetos didáticos e industriais, pois garante que diferentes estilos de codificação permaneçam funcionalmente equivalentes mesmo após modificações locais.

A geração de estímulos segue uma metodologia estruturada baseada em laços `for` aninhados. O laço mais externo percorre os modos numéricos mais relevantes, por exemplo: `num_mode = 3'b000` para unsigned, `3'b001` para signed e `3'b011` para ponto fixo Q com `FRAC = 4`. Para cada modo, um laço intermediário varre todos os valores de `op_sel` de 0 a 15, exercitando o conjunto completo de operações: ADD, SUB, MUL, DIVU, DIVS, DIVQ, operações lógicas, deslocamentos e CMP. Em seguida, dois laços internos percorrem subconjuntos de valores para `op_a` e `op_b` (por exemplo, 0 a 7). Essa faixa é suficiente para gerar uma variedade de casos: somas sem overflow, somas com overflow, subtrações que resultam em valores negativos, multiplicações que extrapolam 8 bits, divisões exatas e divisões com resto, além de eventos de divisão por zero quando `op_b == 0`.

A cada combinação de `(num_mode, op_sel, op_a, op_b)`, o testbench atribui os valores aos registradores de entrada, aguarda um pequeno atraso (`#1` ou `#2`) para permitir a propagação da lógica combinacional e então lê as saídas das três ULAs. O uso de atrasos explícitos é aceitável em testbenches, pois não afeta a síntese — eles são ignorados pelo sintetizador, mas são essenciais para garantir que os sinais já tenham estabilizado antes da comparação. Em seguida, o testbench verifica se `result_behavioral`, `result_dataflow` e `result_structural` são idênticos e faz o mesmo para cada uma das flags. A comparação costuma usar os operadores `!==` e `===`, que levam em conta estados indefinidos (`X`) e de alta impedância (`Z`), evitando que discrepâncias mascaradas por valores indefinidos passem despercebidas.

O testbench também registra o número total de testes executados e o número de erros encontrados. Ao final da simulação, se `error_count == 0`, é impressa uma mensagem do tipo: “SUCESSO: Todas as implementacoes estao consistentes em XXXX testes.” Caso contrário, são exibidas mensagens detalhadas indicando em qual combinação de modo, operação e operandos ocorreu a divergência. Além da verificação textual, o testbench configura a geração de arquivos de waveform (`.vcd` ou formato proprietário do simulador), por meio de chamadas como `$dumpfile` e `$dumpvars`. Isso permite que o projetista abra as formas de onda em ferramentas como GTKWave ou o viewer do ModelSim/Questa e observe, por exemplo, a transição de `op_sel` ao longo do tempo, o comportamento de `num_mode` em blocos e a evolução de `op_a`/`op_b` nos laços internos.

Na análise das formas de onda, é possível identificar claramente padrões interessantes: quando `op_sel = 3` (DIVU) e `op_b = 0`, o resultado é forçado para um valor de saturação e as flags de overflow e saturate são ativadas; quando `op_sel = 0` (ADD) e os operandos produzem overflow em complemento de dois, `flag_overflow` é setada, enquanto em operações lógicas as flags de overflow e carry permanecem zeradas. O alinhamento visual entre os sinais de saída das três ULAs é uma evidência adicional de equivalência funcional. Uma boa prática adicional seria adicionar asserts SystemVerilog ou tarefas que chequem propriedades específicas (por exemplo, “DIVU nunca deve gerar overflow quando B ≠ 0”), o que poderia evoluir o testbench para um ambiente de verificação mais próximo de UVM. Mesmo assim, na forma atual, o `tb_ula_full` já oferece uma cobertura significativa de casos e um fluxo de verificação automatizado e reprodutível.

---

## 5.4 Aplicações Práticas e Extensões Possíveis

Embora a ULA_FULL tenha sido projetada com um forte viés didático, suas características a tornam aplicável em uma série de cenários reais de projeto digital e experimentação em FPGA. Em um contexto de ensino de arquitetura de computadores, por exemplo, a ULA pode ser integrada a um processador simples do tipo RISC monociclo ou multiciclo, funcionando como núcleo aritmético‑lógico do estágio de execução. As instruções de um conjunto ISA didático (ADD, SUB, AND, OR, XOR, SHIFT, CMP, DIV, etc.) podem ser mapeadas diretamente para valores de `op_sel`, enquanto `num_mode` pode ser controlado por campos de formato de instrução ou por registradores de configuração. Nesse cenário, os alunos podem observar, em laboratório, como operações de alto nível em linguagem de montagem são decompostas em sinais de controle que dirigem a ULA, e como flags como zero e carry alimentam instruções de desvio condicional.

Em aplicações de processamento de sinais digitais (DSP) em FPGAs, o suporte a ponto fixo Q torna a ULA_FULL um bloco interessante para prototipar algoritmos como filtros FIR simples, normalização de sinais e algoritmos de controle. Por exemplo, ao representar amostras de áudio em Q4.4 (4 bits inteiros e 4 fracionários) com `WIDTH = 8` e `FRAC = 4`, é possível realizar operações de escala (multiplicações por constantes) e divisões por fatores de normalização diretamente na ULA, antes de migrar para versões otimizadas com multiplicadores dedicados do FPGA. Ainda que, em um projeto industrial, uma divisão combinacional não seja a escolha ideal por motivos de área e timing, o uso da ULA_FULL em fase de prototipagem permite validar rapidamente o comportamento numérico do algoritmo, para depois substituí‑la por blocos mais especializados (como IPs de DSP ou versões pipelined) mantendo a mesma interface externa.

Outro campo de aplicação é o estudo de formatos numéricos personalizados e quantização em redes neurais de baixa precisão. A ULA_FULL pode ser adaptada para operar com larguras menores (por exemplo, 4 ou 6 bits) e modos numéricos ajustados a pesos e ativações quantizados. Dessa forma, é possível simular, em hardware, o impacto de usar aritmética inteira saturada em vez de ponto flutuante tradicional, tema bastante atual em aceleradores de IA. A presença das flags de saturação e overflow ajuda a identificar, em tempo de execução, quando o modelo está extrapolando sua faixa dinâmica, servindo como ferramenta de diagnóstico em protótipos.

Do ponto de vista de fluxo de projeto, a ULA_FULL também é útil como “bloco‑laboratório” para experimentar diferentes estratégias de otimização. Um aluno pode sintetizar o mesmo código em três configurações: (i) versão puramente combinacional, (ii) versão com registradores nas entradas e saídas, (iii) versão pipelined interna com duas ou mais etapas. Em cada caso, é possível comparar área ocupada (LUTs, registradores, DSPs), frequência máxima atingível e consumo de energia estimado. Isso cria um ambiente ideal para discutir trade‑offs clássicos de projeto digital: throughput versus latência, área versus desempenho, legibilidade do código versus controle fino da estrutura resultante.

Finalmente, a ULA_FULL pode servir como base para trabalhos de conclusão de curso ou projetos de pesquisa em ensino de engenharia, documentação de boas práticas e criação de materiais didáticos. O próprio README técnico, com descrições detalhadas de arquitetura, metodologias de teste e aplicações, pode ser usado como exemplo de documentação profissional em repositórios de código. Entre as extensões naturais estão a inclusão de operações mais avançadas (MAC, rotação de bits, contagem de bits 1), modos numéricos adicionais (como saturação assimétrica ou mini‑float com expoente explícito) e integração com barramentos padrão (AXI‑Lite, Wishbone) para uso como periférico configurável em SoCs baseados em FPGA. Em todos esses cenários, a ULA_FULL funciona como um núcleo flexível, transparente e extensível para experimentação e aprendizagem em sistemas digitais.

