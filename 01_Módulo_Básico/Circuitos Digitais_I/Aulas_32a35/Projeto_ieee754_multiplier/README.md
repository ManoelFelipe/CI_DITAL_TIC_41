# Projeto — `ieee754_multiplier` (IEEE 754 Single Precision)

**Autor:** Manoel Furtado  
**Data:** 11/11/2025

Este projeto implementa um multiplicador em ponto‑flutuante IEEE 754 simples (32 bits) em três estilos de descrição HDL: **Behavioral**, **Dataflow** e **Structural**. A arquitetura separa sinal, expoente (8 bits) e fração (23 bits com bit oculto), realiza a multiplicação 24×24 das mantissas, normaliza o produto de 48 bits e ajusta o expoente pelo bias (127). O arredondamento adotado é **truncamento** (round‑toward‑zero), suficiente para fins didáticos de comparação entre estilos. Todo o datapath é **combinacional**, com latência de 0 ciclos; assim, o caminho crítico é dominado pelo multiplicador 24×24, somador de expoente (9–10 bits) e normalizador (priority‑encoder).

> Diretórios prontos para **Quartus** e **Questa** foram providos, bem como scripts `.do` para limpeza, compilação e execução.

---

## 5.2 Análise das Abordagens

**Behavioral.** A versão comportamental utiliza um único bloco `always @*` para coordenar a lógica: extração de campos, detecção de zero, produto 24×24, soma dos expoentes com subtração do bias, seguida por normalização. A normalização testa o bit 47 do produto para decidir entre shift implícito (quando `1`) ou deslocamento à esquerda até o primeiro `1`, usando um **laço determinístico** que se sintetiza como um *priority encoder*. Essa abordagem é **rápida de escrever e fácil de manter**, ideal para modelagem funcional. O risco principal é **agregar muita lógica** dentro de um único bloco, tornando o caminho crítico longo e dificultando *timing closure* em FPGAs quando a frequência alvo cresce. Para mitigações, costuma‑se inserir **registradores de pipeline** (não aplicados aqui, por exigência do enunciado), ou isolar etapas em submódulos. Em síntese, o estilo behavioral fornece **clareza e compacidade**, com excelente legibilidade para ensino e *bring‑up* inicial.

**Dataflow.** Na versão dataflow privilegia‑se **expressões contínuas** (`assign`) e **funções puras** para encapsular operações combinacionais complexas, em especial a **normalização** de 48 bits em uma função `normalize48`. Tal função não contém estados: recebe `prod` e `exp_in`, devolvendo a tupla `{exp, mantissa}` já ajustada. Esse padrão facilita a **verificação formal e linting**, pois a dependência entre sinais é explícita no grafo de dados. Em termos de síntese, a estrutura gerada é muito semelhante à behavioral, porém com **particionamento lógico** mais claro, o que pode ajudar o **sintetizador** na inferência de *sharing* e na movimentação de lógica. Riscos: abusar de funções com laços pode gerar prioridade difícil de otimizar; além disso, funções extensas podem esconder **caminhos críticos**. Ainda assim, dataflow é excelente quando se quer **transparência do fluxo de dados** e **reutilização** de transformações combinacionais.

**Structural.** O estilo estrutural decompõe o circuito em **blocos elementares**: `hidden_bit`, `mult24x24`, `exp_add_bias`, `normalizer48` e portas simples (`xor2`). A vantagem é a **modularidade extrema**: cada bloco pode ser **substituído** por uma implementação de biblioteca (por exemplo, um IP de multiplicador DSP do FPGA) sem alterar a integração geral. Isso favorece **pipelines seletivos** e **floorplanning** quando o alvo é alto desempenho. O principal custo é **verbosidade** e maior esforço de integração. Em termos de área/tempo, a qualidade do resultado depende fortemente do **módulo de multiplicação** e do **normalizador**; a divisão em submódulos não piora por si só o desempenho, mas pode limitar otimizações interbloco se o sintetizador não fizer *flatten*. Em projetos grandes de ponto flutuante, o estilo estrutural é a base para **versionamento de IPs** (ex.: trocas controladas de normalizador/rounder).

---

## 5.3 Metodologia do Testbench

O testbench (`tb_ieee754_multiplier.v`) segue uma estratégia **autoconsistente**: a validação é feita por uma **referência bit‑a‑bit interna** (`mul_ref`) que replica o algoritmo combinacional usado no modelo behavioral, garantindo **comparação exata** de campos `sinal|expoente|fração`. Essa referência **não depende de `real`/`$bitstoreal`**, evitando divergências de arredondamento entre *single* e *double*. O TB instancia o DUT (definido no caminho selecionado pelos scripts `.do`) e gera estímulos com `#delays`. Primeiro, aplica **vetores dirigidos** com significado numérico claro: `4.75×2.125`, `9.5×3.75`, e casos de **zero**. Em seguida, executa um **laço** de vinte iterações com padrões paramétricos, variando campos altos de `a` e `b`. Para cada amostra, o TB calcula `expect = mul_ref(a,b)` e compara com a saída do DUT usando **comparação de 4‑valores** (`!==`), registrando falhas com `$display` detalhando `A`, `B`, `DUT` e `REF`. Um **acumulador de sucesso** (`success`) resume o status ao final. Para análise de formas de onda, o TB habilita **VCD** (`$dumpfile/$dumpvars`) desde o topo (`tb_ieee754_multiplier`), permitindo inspecionar tanto sinais de entrada/saída quanto internos (quando o simulador expõe hierarquia). Por fim, imprime “Fim da simulacao.” e invoca `$finish` para encerramento limpo. Boas práticas aplicadas incluem: inicialização explícita, ausência de *latches* no TB, uso de `timescale 1ns/1ps`, e **mensagens rastreáveis** que aceleram a depuração.

---

## 5.4 Aplicações Práticas

Multiplicação IEEE 754 é pilar de **gráficos 3D**, **visão computacional**, **ML inferência/treino** (quando em FP32) e **simulações científicas**. Em GPUs, arranjos massivos de multiplicadores FP se combinam a somadores (`FMA`) para **acumulação** de produtos. Em FPGAs, embora seja comum priorizar **fixo** por custo, FP32 aparece em **pré‑processamentos** (normalizações, transformadas) e **interface** com software legado. O núcleo aqui descrito é adequado como **building block** em: (1) bibliotecas de **ALUs FP** educacionais; (2) **coprocessadores** de ponto flutuante com *latência zero* (para pequenas frequências); (3) **pipelines** onde se deseja demonstrar o efeito de **normalização** e de **políticas de arredondamento**. Para síntese real, adiciona‑se **rounding to nearest even**, **tratamento de exceções** (NaN, ±Inf, subnormais, overflow/underflow), **sticky/guard/round bits** e **flags** (NV, DZ, OF, UF, NX). Em projetos de alto f*clk, introduz‑se **pipeline**: p.ex., estágio 1 (separação e soma de expoente), estágio 2 (mul 24×24 via blocos DSP), estágio 3 (normalização/round), cada um com registros; isso mantém throughput de **1 resultado/ciclo** após *fill*. Em termos de integrações, sugerem‑se **interfaces AXI‑Stream** para acoplamento em SoCs e **módulos de handshaking** (`valid/ready`) para compor filas. Boas práticas incluem validação cruzada com **bibliotecas C** e geração de vetores pela **soft‑float**. Mesmo sem arredondamento completo, o presente projeto ilustra **toda a mecânica essencial** de FP32 e serve como base para incrementos graduais com métricas de área/tempo e cobertura funcional.
