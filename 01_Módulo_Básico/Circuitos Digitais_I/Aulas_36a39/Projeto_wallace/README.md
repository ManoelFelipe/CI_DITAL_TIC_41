# Projeto Wallace Tree 4×4 — Verilog (Behavioral, Dataflow, Structural)

**Autor:** Manoel Furtado  
**Data:** 11/11/2025

## 5.1 Descrição do Projeto
Este projeto implementa um multiplicador inteiro sem sinal de 4×4 bits com saída de 8 bits empregando três estilos de descrição em Verilog 2001: **Behavioral**, **Dataflow** e **Structural**. A referência conceitual é a **árvore de Wallace**, técnica clássica de redução paralela de produtos parciais usando somadores de 1 bit (Half Adders e Full Adders). Embora a abordagem comportamental utilize o operador `*`, ferramentas de síntese para FPGA costumam inferir uma rede funcionalmente equivalente a ANDs + somadores, podendo mapear para LUTs e carry-chains do dispositivo. A versão **Dataflow** expõe explicitamente a geração dos 16 produtos parciais `a[i]&b[j]` e executa a redução em “colunas” com expressões booleanas (`^`, `&`, `|`), preservando o espírito de Wallace sem instâncias explícitas. A versão **Structural** materializa a árvore por meio de módulos `half_adder` e `full_adder`, permitindo inspeção granular das **frentes de carry** e do **grau de paralelismo**.

O projeto acompanha **testbench auto‑verificante** que varre todas as 256 combinações possíveis de entrada e compara os três estilos com uma referência de ouro. São fornecidos scripts `do` para **Questa/ModelSim** que automatizam limpeza, compilação e execução, além de um layout de diretórios compatível com fluxos comuns de **Quartus** e **Questa**. A latência é totalmente combinacional (0 ciclos). Em termos de recursos, a versão estrutural usa 16 ANDs para gerar parciais e uma malha de somadores de 1 bit para reduzir colunas até o resultado final, com complexidade pequena o bastante para análises de **timing** e de **pós‑síntese** em FPGAs entry‑level.

## 5.2 Análise das Abordagens
**Behavioral.** A descrição comportamental resume a funcionalidade em uma única atribuição: `assign produto = a * b;`. A síntese reconhece o operador como multiplicação inteira sem sinal e mapeia para uma implementação nativa do fornecedor (por exemplo, DSPs, LUTs com carry‑chain ou lógica combinacional compacta). Vantagens: legibilidade extrema, menor probabilidade de erros e portabilidade. Riscos: a implementação real fica a critério do mapeador; restrições de área/clock podem exigir diretivas (por exemplo, `multstyle=logic` em alguns fluxos) para evitar o uso de blocos DSP. Em 4×4 bits, o impacto é mínimo, mas a lição vale para larguras maiores. Um ponto didático é comparar o atraso crítico após síntese com e sem a opção de usar carry‑chain dedicada.

**Dataflow.** Nesta versão, a rede é descrita com **equações booleanas**: primeiro os 16 produtos parciais (`a[i]&b[j]`), depois a redução por colunas usando XOR/AND/OR. Segue‑se uma propagação de carries (ripple) que realiza o papel dos níveis da árvore, gerando `produto[0]` diretamente, somando pares na coluna 1, reduzindo ternas (full adder) nas colunas 2–5 e propagando os *carries* à direita. Vantagens: alta transparência do caminho de dados, ótimo para depuração e verificação formal, sem dependência de submódulos. Limitações: verbosidade; maior chance de inconsistências de largura se o autor não comentar e nomear bem os sinais. Em FPGAs, o mapeamento costuma explorar o **fast carry** automaticamente graças ao padrão de XOR/AND/OR empregado.

**Structural.** A implementação estrutural instancia explicitamente **`half_adder`** e **`full_adder`** conforme a figura tradicional de Wallace para 4×4. Cada coluna do arranjo é reduzida no menor número de níveis possível; os *carries* são roteados para colunas superiores e as somas permanecem na mesma coluna, até restar uma soma final estilo ripple entre duas linhas. Benefícios: completa visibilidade de granularidade porta‑a‑porta, ideal para ensino, medições de atraso por estágio, e para substituição dirigida (por exemplo, trocar um `full_adder` por uma célula otimizada). Trade‑offs: mais arquivos, maior esforço de manutenção e suscetibilidade a erros de conexão. A equivalência com as demais abordagens é garantida pelo testbench exaustivo (256 vetores). Em síntese, a **structural** fornece o melhor controle, a **dataflow** o melhor equilíbrio entre clareza e concisão, e a **behavioral** a melhor produtividade.

## 5.3 Metodologia do Testbench
O `tb_wallace.v` foi escrito como **testbench auto‑verificante** e totalmente **combinacional**, com `\`timescale 1ns/1ps`. O bloco `initial` percorre dois laços aninhados `for (i=0..15)` e `for (j=0..15)` cobrindo todas as entradas `a` e `b`. Para cada par, aguarda‑se um **#1** de acomodação (evita leituras em zero‑tempo em simuladores com *delta cycles*), e então compara‑se as saídas das três instâncias com uma **referência de ouro** baseada em multiplicação inteira (`i*j`). A checagem usa operadores **case‑equality** (`!==`) para detectar *X/Z* anômalos. Toda discrepância incrementa o contador de erros e imprime um relatório detalhado contendo os três resultados divergentes. Ao fim da varredura, o testbench imprime **“Todas as 256 combinacoes passaram…”** quando não há falhas, ou **“Falhas detectadas: N”** caso contrário.

O testbench também habilita geração de **VCD** (`$dumpfile/$dumpvars`), útil para inspecionar as colunas da árvore e o percurso dos *carries*. A hierarquia completa é exportada com `0, tb_wallace`, permitindo observar sinais internos dos submódulos estruturais (`ha**`, `fa**`). A estratégia evita *latches* acidentais (não há `always` sequenciais), assegura inicialização explícita de registradores e não usa recursos de SystemVerilog, garantindo **compatibilidade** ampla. Em termos de boas práticas, separar **referência** (instância comportamental) das **implementações** reduz a chance de mascarar erros; a espera de `#1` mantém a simulação determinística; e o uso de **flags** (`sucesso`) facilita integração com *scripts* CI que examinam a transcrição em busca de “Falhas”/“passaram”.

## 5.4 Aplicações Práticas
Multiplicadores compactos 4×4 são a base de componentes maiores: formam **blocos parciais** em multiplicadores 8×8 (por decomposição em “quartetos”), compõem **MACs** (Multiply‑Accumulate) de filtros FIR/IIR, e participam da aritmética de **ponto fixo** de pipelines de controle. Em FPGAs modernos, multiplicações pequenas podem ser implementadas em **LUTs** com **carry‑chain** quando os DSPs devem ser preservados para operações de maior largura. Por exemplo, em uma cadeia de processamento de imagens 8 bits, múltiplos blocos 4×4 podem ser paralelizados para realizar **convoluções 3×3**, acumulando resultados com *carry-save* antes da normalização. Outra aplicação didática é a construção de **multiplicadores Booth**: o 4×4 Wallace aqui implementado pode servir como **núcleo parcial** após recodificação de dígitos.

No domínio de **projeto digital educacional**, o módulo estrutural com `half_adder`/`full_adder` permite medições de **atraso por estágio** e experiências de **retiming**—substituindo somadores por versões *look‑ahead* para observar impacto no *slack*. Em ASICs, a mesma topologia de Wallace escala para 16×16 ou 32×32 combinando **árvores de compressão (3:2, 4:2)** e somadores finais do tipo **CLA**. Em sistemas embarcados de baixa potência, versões **clock‑gated** ou **serializadas** (iterativas) competem quando throughput não é crítico; já em **sinais/multimídia**, arrays densos 4×4 replicados maximizam throughput. Boas práticas incluem: congelar interfaces (a,b,produto), criar **parametrizações** para largura N, e avaliar pós‑síntese o uso de **carry‑chain** versus **DSPs** através de *constraints* do *vendor*. Assim, este projeto é um **tijolo fundamental** tanto para ensino quanto para arquiteturas reais de processamento.
