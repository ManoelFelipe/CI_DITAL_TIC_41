# Projeto: Registrador SIPO de 8 Bits Bidirecional

## 5.1 Descrição do Projeto
**Autor:** Manoel Furtado  
**Data:** 25/11/2025  

Este projeto consiste na implementação de um Registrador de Deslocamento com Entrada Serial e Saída Paralela (SIPO - Serial-In Parallel-Out) de 8 bits, com capacidade de deslocamento bidirecional. O circuito é fundamental em sistemas digitais para conversão de dados seriais (como em protocolos SPI, I2C ou UART) para formatos paralelos que podem ser processados por microprocessadores ou FPGAs.

A arquitetura foi projetada para operar de forma síncrona com a borda de subida do clock e possui um reset assíncrono ativo em nível alto. A principal característica funcional é o controle de direção através do sinal `dir`: quando `dir=0`, o deslocamento ocorre para a direita (o bit de entrada `din` entra na posição mais significativa e os dados fluem em direção ao bit menos significativo); quando `dir=1`, o deslocamento ocorre para a esquerda (o bit de entrada `din` entra na posição menos significativa e os dados fluem em direção ao bit mais significativo). O projeto foi desenvolvido seguindo rigorosamente o padrão Verilog-2001 e validado através de três abordagens de modelagem distintas (Behavioral, Dataflow e Structural) para garantir robustez e fins didáticos.

## 5.2 Análise das Abordagens

### Implementação Behavioral
A implementação **Behavioral** (`reg_sipo_8_behav.v`) descreve o comportamento do circuito em alto nível de abstração, focando no algoritmo de funcionamento e não na estrutura física. Utiliza um bloco `always` sequencial sensível à borda do clock e ao reset. Dentro deste bloco, estruturas condicionais `if-else` determinam a operação de deslocamento baseada no sinal `dir`. O operador de concatenação `{}` é utilizado de forma eficiente para realizar o shift: `q <= {din, q[7:1]}` para direita e `q <= {q[6:0], din}` para esquerda. Esta abordagem é a mais legível, fácil de manter e é a preferida para síntese lógica moderna, pois permite que a ferramenta de síntese otimize o hardware (escolhendo entre flip-flops com enable, muxes ou shift registers dedicados) sem restrições estruturais impostas pelo designer. O risco de latches é eliminado pelo uso correto de `else` e atribuições não-bloqueantes (`<=`) para lógica sequencial.

### Implementação Dataflow
A implementação **Dataflow** (`reg_sipo_8_data.v`) modela o fluxo de dados através do circuito utilizando atribuições contínuas (`assign`) para a lógica combinacional de próximo estado e um bloco `always` mínimo apenas para a inferência dos elementos de memória (registrador). A lógica de decisão do deslocamento é implementada com o operador ternário condicional `? :`, que atua como um multiplexador abstrato: `assign next_q = (dir == 0) ? ... : ...`. Esta abordagem separa claramente a lógica de controle (combinacional) da lógica de armazenamento (sequencial), oferecendo uma visão clara do caminho de dados ("Register Transfer Level" - RTL). Em termos de síntese, produz resultados muito similares à comportamental, mas pode ser mais verbosa para lógicas complexas. É excelente para visualizar o atraso de propagação entre estágios de registradores.

### Implementação Structural
A implementação **Structural** (`reg_sipo_8_struct.v`) é a de menor nível de abstração, descrevendo o circuito como uma lista de conexões (netlist) entre componentes básicos. Neste projeto, foram instanciados explicitamente 8 Flip-Flops tipo D e a lógica de multiplexação necessária para cada bit. Para cada estágio `i`, um multiplexador 2:1 seleciona a entrada do Flip-Flop entre o vizinho da esquerda (`q[i+1]`) ou da direita (`q[i-1]`), dependendo do sinal `dir`. O uso de `generate` e `for` loop em Verilog-2001 permitiu descrever a estrutura repetitiva de forma concisa, mantendo a natureza estrutural. Esta abordagem oferece controle total sobre o hardware gerado e é útil para otimizações manuais críticas de área ou potência, ou para mapeamento direto em tecnologias específicas (ASIC), mas é mais propensa a erros de conexão manual e mais difícil de alterar.

## 5.3 Descrição do Testbench
O testbench (`tb_reg_sipo_8.v`) foi desenvolvido com uma metodologia de **verificação cruzada simultânea**. As três implementações (DUTs) são instanciadas e estimuladas com os mesmos sinais de entrada (`clk`, `rst`, `din`, `dir`) ao mesmo tempo. A verificação não depende apenas de inspeção visual; um processo automático monitora as saídas `q_behav`, `q_data` e `q_struct` a cada borda de descida do clock (para garantir estabilidade dos dados). Se houver qualquer divergência entre as saídas das três implementações, uma mensagem de erro é impressa com o timestamp e os valores dos sinais, e um contador de erros é incrementado.

A simulação começa com um reset global, seguido por testes direcionados para validar o deslocamento à direita (inserindo padrões conhecidos como '1' e '0') e, em seguida, a inversão da direção para deslocamento à esquerda. O uso de `$display` formatado gera uma tabela didática no console, permitindo acompanhar ciclo a ciclo o estado das entradas e a evolução do registrador. O testbench é auto-verificável: ao final da simulação, ele reporta explicitamente "SUCESSO" se zero erros forem detectados, ou "FALHA" caso contrário. Isso garante que qualquer alteração futura no código que quebre a equivalência lógica será imediatamente detectada. O arquivo `wave.vcd` é gerado para análise detalhada de temporização e transições.

## 5.4 Aplicações Práticas
O registrador SIPO bidirecional é um componente versátil em engenharia digital.
1.  **Interfaces de Comunicação Serial:** É o bloco fundamental em receptores de protocolos como **UART, SPI e I2C**. No SPI, por exemplo, os dados entram serialmente (MISO/MOSI) e são convertidos para paralelo para serem lidos pelo processador. A bidirecionalidade permite suportar variações de protocolo que transmitem LSB-first ou MSB-first sem alterar o hardware, apenas mudando o sinal de controle.
2.  **Conversão de Dados em DSP:** Em processamento digital de sinais, filtros digitais e operações de convolução frequentemente requerem janelas deslizantes de dados. Um registrador de deslocamento pode armazenar as últimas N amostras de um sinal de áudio ou sensor, deslocando os dados a cada novo sample, permitindo operações paralelas de multiplicação e acumulação (MAC) eficientes.
3.  **Controle de LEDs e Displays:** O popular CI 74HC595 é essencialmente um registrador SIPO. Ele é usado para expandir portas de saída de microcontroladores (como Arduino), permitindo controlar 8 (ou mais, em cascata) LEDs ou displays de 7 segmentos usando apenas 3 pinos de controle (Data, Clock, Latch).
4.  **Testes de Hardware (Scan Chains):** Em Design for Testability (DFT), registradores internos de um chip são conectados em longas cadeias de deslocamento (scan chains). Durante o modo de teste, vetores de teste são inseridos serialmente para configurar o estado interno de todo o chip, e os resultados são lidos serialmente na saída, permitindo diagnosticar falhas de fabricação em chips complexos com milhões de transistores.
