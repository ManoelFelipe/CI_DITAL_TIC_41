# Contador Ascendente Módulo 100 – Projeto em HDL (Verilog)

## 5.1 Descrição do Projeto

Autor: **Manoel Furtado**  
Data: **26/11/2025**

Este projeto implementa um contador síncrono ascendente módulo 100, desenvolvido em Verilog, com o objetivo de consolidar conceitos de lógica sequencial, reset assíncrono e modelagem RTL em diferentes estilos de descrição (behavioral, dataflow e structural). O circuito deve contar de 0 até 99, utilizando um clock de 100 MHz, possuir reset assíncrono ativo em nível alto e reiniciar automaticamente após atingir o valor máximo de contagem. Assim, ele se comporta como um contador módulo 100: a sequência de saída é 0, 1, 2, ..., 98, 99, 0, 1, ... de forma cíclica enquanto o clock estiver ativo e o reset estiver desativado.

Para representar números até 99 em binário, são necessários 7 bits, uma vez que 2⁶ = 64 é insuficiente e 2⁷ = 128 cobre toda a faixa desejada de 0 a 99. Dessa forma, o projeto utiliza uma largura parametrizável, mas com valor padrão de 7 bits, permitindo futura reutilização do módulo em situações em que seja necessário alterar o limite de contagem apenas ajustando o parâmetro `MAX_COUNT`. O reset assíncrono garante que o sistema possa ser forçado ao estado inicial imediatamente, independentemente da borda do clock, o que é comum em circuitos reais que precisam partir de um estado conhecido assim que a placa é ligada ou quando ocorre alguma falha.

O projeto foi organizado em uma estrutura de diretórios que separa os arquivos destinados ao Quartus e ao Questa, mantendo cópias dos módulos RTL para cada ferramenta e um diretório específico para o testbench e scripts de simulação. Além disso, são fornecidas três variações do contador com o mesmo comportamento, mas escritas em estilos de descrição diferentes: uma versão behavioral, focada na clareza; uma versão dataflow, que separa a lógica combinacional do armazenamento; e uma versão estrutural, que explicita o caminho de dados por meio da interconexão de blocos menores, como registradores, somadores, comparadores e multiplexadores. Essa abordagem oferece uma visão abrangente das formas de se descrever um mesmo hardware em HDL.

## 5.2 Análise das Abordagens

A implementação **behavioral** descreve o contador usando um único bloco `always` sensível à borda de subida do clock e ao reset assíncrono. Dentro desse bloco, são utilizados comandos condicionais `if` para priorizar o reset, detectar o momento em que a contagem atinge `MAX_COUNT` e realizar o incremento normal nos demais ciclos. Esse estilo se aproxima de uma descrição algorítmica, semelhante a um pseudo-código em C ou em uma linguagem de alto nível, facilitando a compreensão do fluxo de controle. Em síntese, o projetista foca no “o que” o circuito deve fazer, deixando para a ferramenta de síntese a tarefa de mapear esse comportamento em flip-flops, comparadores e somadores. Do ponto de vista de riscos de síntese, a abordagem behavioral é geralmente segura quando bem estruturada, pois produz um caminho de dados único e claro; contudo, é importante manter o bloco sempre sensível ao clock e ao reset, evitando condições que possam inferir latches indesejados.

Na implementação **dataflow**, o comportamento é preservado, mas o código é reorganizado para destacar a separação entre lógica combinacional e armazenamento. Um registrador interno (`count_reg`) mantém o valor atual da contagem, enquanto sinais intermediários (`max_reached` e `next_count`) são definidos por meio de instruções `assign`. O sinal `max_reached` representa o resultado da comparação entre o valor atual e `MAX_COUNT`, e `next_count` seleciona, por meio de um operador condicional ternário, se o próximo valor será zero ou o valor atual incrementado em um. O bloco `always` passa a cuidar exclusivamente do carregamento do próximo valor no registrador, mantendo o estilo RTL clássico “registrador + lógica do próximo estado”. Em termos de síntese, essa decomposição explicita funciona bem, pois cada expressão combinacional pode ser otimizada individualmente pelo compilador, o que é útil em projetos maiores onde o caminho de dados precisa ser cuidadosamente controlado para atender requisitos de temporização.

Já a implementação **structural** avança um passo além, decompondo o contador em blocos menores explicitamente instanciados: um registrador com reset assíncrono (`reg_async_nbits`), um somador de incremento em 1 (`adder_inc_nbits`), um comparador de igualdade com uma constante (`comparator_eq_nbits`) e um multiplexador 2:1 (`mux2_nbits`). O módulo principal conecta esses blocos de forma que o valor armazenado no registrador seja enviado ao somador, incrementado em 1 e encaminhado ao multiplexador; o comparador observa o valor atual e, quando detecta que ele é igual a `MAX_COUNT`, aciona o seletor do multiplexador para escolher o valor zero ao invés do valor incrementado. Assim, o caminho de dados fica completamente explícito, como em um diagrama de blocos tradicional. Em projetos grandes, esse estilo é particularmente útil para documentação e análise de área e de timing, já que cada bloco pode ser sintetizado e estudado de forma isolada. O risco principal é aumentar o número de arquivos e a complexidade de manutenção, mas, em compensação, o controle fino da arquitetura é significativamente maior.

## 5.3 Descrição do Testbench

O testbench `tb_count_ascendente_100` foi projetado para validar simultaneamente as três implementações do contador, garantindo que todas produzam exatamente o mesmo comportamento quando submetidas ao mesmo conjunto de estímulos. A geração do clock é feita por um bloco `initial` que alterna o sinal `clk` a cada 5 ns, resultando em um período total de 10 ns, equivalente a uma frequência de 100 MHz, como especificado no enunciado da atividade. O reset assíncrono é aplicado em um segundo bloco `initial`: ele começa ativo, permanece assim por 20 ns (garantindo pelo menos duas bordas de clock), é desativado e, após algum tempo, é aplicado novamente como um segundo pulso de teste. Essa estratégia permite verificar não apenas a inicialização, mas também o comportamento do contador quando é resetado no meio da contagem.

Depois do reset inicial, o testbench entra em um laço `for` que executa pelo menos 300 ciclos de clock, o que garante a observação de várias voltas completas do contador (já que um período completo de 0 a 99 consome 100 ciclos). Em cada iteração, após uma borda de subida do clock, o testbench incrementa um contador de testes (`total_tests`) e compara as saídas das três DUTs (`count_behav`, `count_data` e `count_struct`). Se qualquer par de saídas não coincidir, uma mensagem de erro é exibida com o tempo simulado e os valores divergentes, e uma flag de sucesso é zerada. Ao final do laço, se nenhuma divergência foi detectada, o testbench imprime a mensagem obrigatória:  
`"SUCESSO: Todas as implementacoes estao consistentes em %0d testes."`, indicando que as três abordagens são funcionalmente equivalentes para todo o conjunto de estímulos aplicado.

Paralelamente ao laço principal de verificação, há um terceiro bloco `initial` responsável pela geração de uma tabela didática com base apenas na implementação behavioral. Esse bloco aguarda o término do reset e, então, imprime um cabeçalho seguido de 16 linhas, cada uma correspondente a um ciclo de clock. Em cada linha são mostrados o tempo em nanossegundos, o valor decimal do contador e o valor binário em 7 bits. Essa tabela auxilia no entendimento da evolução temporal da contagem, permitindo ao aluno conferir rapidamente se os valores observados batem com o esperado (0, 1, 2, ..., 15, por exemplo). Além disso, o testbench inclui a geração de um arquivo `wave.vcd` usando `$dumpfile` e `$dumpvars`, possibilitando que as formas de onda sejam inspecionadas em ferramentas como GTKWave ou o próprio visualizador do Questa. Por fim, a simulação é encerrada de forma limpa com `$finish`, evitando loops infinitos e travamentos.

## 5.4 Aplicações Práticas

Contadores modulares como o desenvolvido neste projeto são blocos fundamentais em uma vasta gama de sistemas digitais, desde circuitos simples de temporização até arquiteturas complexas de comunicação e processamento de sinais. Um contador módulo 100, em particular, é bastante natural em aplicações que envolvem contagens relacionadas a porcentagens, amostragens periódicas em janelas de 100 ciclos, ou ainda em implementações de contadores “decimais compactos”, em que se deseja agrupar 100 estados possíveis em um único registrador binário. Em sistemas embarcados, por exemplo, é comum utilizar contadores síncronos para gerar eventos com períodos específicos a partir de um clock mais rápido. Considerando um clock de 100 MHz, nosso contador completa um ciclo completo em 100 pulsos, ou seja, em 1 µs. Assim, ele pode ser usado como base para subdivisões de tempo ou como parte de um temporizador mais sofisticado quando combinado com divisores adicionais.

Outra aplicação típica é em interfaces homem-máquina, como contadores de eventos em painéis, máquinas industriais e sistemas de aquisição de dados. Em vez de representar diretamente cada estado em um display, o contador pode ser usado como índice para acessar tabelas de memória, sequências de LEDs ou etapas de um processo de controle. Por exemplo, um sistema pode utilizar o contador módulo 100 para percorrer repetidamente uma lista de 100 amostras de calibração, aplicando cada valor a um DAC em sequência. Em telecomunicações, contadores semelhantes são usados para gerar pseudocódigos de varredura, escalonar pacotes ou implementar janelas de transmissão. O fato de o contador ser parametrizável permite ajustar rapidamente o limite de contagem para outros valores (como 50, 200 ou 256) apenas alterando o parâmetro `MAX_COUNT` e, se necessário, a largura `WIDTH`.

Do ponto de vista de projeto de hardware, o exercício de implementar o mesmo contador em estilos behavioral, dataflow e structural ajuda a criar uma visão mais rica da relação entre código HDL e o hardware resultante. Em aplicações reais, o engenheiro pode começar com uma descrição behavioral simples para validar a funcionalidade, migrar para uma versão dataflow para ganhar controle sobre o caminho de dados e, por fim, adotar uma descrição estrutural quando for necessário integrar o bloco em uma arquitetura maior, composta por diversos módulos reutilizáveis. Em FPGAs, isso se traduz em melhor aproveitamento de LUTs, registradores e recursos dedicados de somadores, permitindo cumprir metas de temporização rigorosas. Portanto, embora o contador módulo 100 pareça um circuito simples, ele serve como um excelente laboratório para explorar práticas de projeto digital que serão reutilizadas em sistemas muito mais complexos.
