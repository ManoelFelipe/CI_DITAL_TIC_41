# Projeto FIFO 16x16 com Buffer Circular — Três Abordagens em Verilog

## 5.1 Descrição do Projeto

Autor: **Manoel Furtado**  
Data: **11/12/2025**  

Este projeto implementa uma FIFO (First-In, First-Out) síncrona com buffer circular, parametrizada quanto à largura da palavra (`DATA_WIDTH`) e ao número de posições de armazenamento (`DEPTH`). Para atender ao enunciado do exercício, a configuração de referência utilizada no testbench é de **16 elementos com 16 bits** cada, mas o código foi escrito de forma a permitir alterações simples nesses parâmetros. A FIFO expõe uma interface clássica composta por `clk`, `rst`, `wr_en`, `rd_en`, `data_in`, `data_out`, `full` e `empty`. O sinal `rst` é assíncrono e ativo em nível alto, garantindo a inicialização limpa da estrutura antes do início da operação.

A arquitetura geral baseia-se em um **buffer circular** implementado sobre uma memória interna, dois ponteiros (de leitura e de escrita) e um contador de ocupação. Quando um novo dado é gravado, o ponteiro de escrita avança; quando um dado é lido, o ponteiro de leitura é incrementado. O contador de ocupação acompanha a diferença entre essas operações, permitindo a geração dos flags `full` e `empty`. Esse modelo é amplamente utilizado em sistemas embarcados, pipelines digitais, interfaces de comunicação e buffers de dados em FPGAs.

O projeto foi organizado em três implementações distintas — **Behavioral**, **Dataflow** e **Structural** — para reforçar a compreensão dos diferentes estilos de descrição em Verilog. Todas as versões compartilham a mesma interface externa e são parametrizadas de forma equivalente, permitindo o reuso do mesmo testbench. O arquivo de teste instancia simultaneamente as três variantes e compara suas saídas ciclo a ciclo, garantindo consistência funcional. Além disso, scripts em Tcl foram criados para automatizar a limpeza, compilação e simulação no ambiente Questa/ModelSim, evitando trabalhos manuais repetitivos e reduzindo a chance de erro de configuração.

Por fim, o projeto segue uma organização de diretórios compatível com fluxos típicos de desenvolvimento: há uma pasta específica para arquivos de síntese no Quartus e outra para simulação no Questa, mantendo o código RTL duplicado apenas por conveniência de uso em ferramentas distintas. O foco é estabelecer uma base didática sólida, mas já alinhada com boas práticas profissionais, facilitando a evolução do projeto para tamanhos de FIFO maiores e aplicações mais exigentes em termos de temporização e área.

## 5.2 Análise das Abordagens

### Implementação Behavioral

A implementação Behavioral descreve a FIFO utilizando um único bloco `always` sensível à borda de subida do clock e ao reset assíncrono. Dentro desse bloco são controlados os ponteiros de leitura e escrita, o contador de ocupação e o registrador de saída. Esse estilo se aproxima de uma descrição “algorítmica”: raciocinamos como se estivéssemos escrevendo um pseudo-código que manipula variáveis inteiras e vetores, deixando que o sintetizador traduza essa lógica em hardware. O principal benefício é a clareza: é fácil enxergar a sequência de operações — verificar se há espaço, escrever ou ler dados, atualizar ponteiros e contador.

Do ponto de vista de síntese, a abordagem Behavioral é bastante flexível. As ferramentas conseguem reconhecer um padrão típico de FIFO e mapeá-lo para **block RAM** ou **distributed RAM**, conforme a arquitetura do FPGA e as diretivas de síntese. A lógica de ponteiros foi atualizada para suportar **profundidades arbitrarias** (não apenas potências de 2) através de verificação condicional de limite, garantindo flexibilidade total. Também é fundamental garantir que não haja condições ambíguas em que leitura e escrita acontecem simultaneamente sem ter sido claramente especificado o comportamento, pois isso pode gerar inconsistências entre simulação e síntese.

Outro ponto relevante é o tratamento do reset assíncrono. Zerar ponteiros, contador e saída é simples, mas zerar toda a memória exigiria laços adicionais que não são bem-vindos em hardware real. Por isso, o reset atua apenas sobre os registradores principais, deixando a memória com conteúdo indefinido até que novas escritas a preencham. Essa decisão é aceitável na maioria das aplicações digitais, desde que a lógica ao redor não dependa do valor inicial dos dados lidos imediatamente após o reset.

### Implementação Dataflow

Na variante Dataflow, a FIFO é dividida claramente em duas partes: uma porção **combinacional**, que calcula sinais de próximo estado (`next_wr_ptr`, `next_rd_ptr`, `next_count`, `next_data_out`), e uma porção **sequencial**, que apenas registra esses valores na borda de subida do clock. As atribuições combinacionais são realizadas com `assign` e operadores condicionais, destacando o caminho que os dados percorrem antes de serem armazenados nos registradores. Essa abordagem melhora a legibilidade quando se deseja analisar dependências de sinais e facilita a depuração de problemas de temporização, pois cada transformação é visível em forma de expressão.

Do ponto de vista de síntese, o hardware resultante é essencialmente o mesmo da versão Behavioral, desde que o conteúdo lógico seja equivalente. As ferramentas irão gerar os mesmos recursos de memória e registradores, porque internamente elas convertem ambos os estilos para representações intermediárias semelhantes. Entretanto, o estilo Dataflow tende a oferecer vantagem em projetos muito grandes ou altamente otimizados, pois torna mais imediato o ajuste manual de caminhos críticos: é possível reestruturar expressões combinacionais, dividir lógica em estágios adicionais ou inserir registros de pipeline com maior facilidade.

Um cuidado necessário nessa abordagem é evitar **loops combinacionais** involuntários ou condições parcialmente especificadas. Como a saída combinacional é constantemente derivada dos estados atuais, qualquer dependência circular pode criar os famigerados sinais com valor `X` na simulação. No projeto atual, esse risco é mitigado pela definição clara das condições de leitura e escrita (`write_ok` e `read_ok`) e pela forma direta com que o próximo contador é calculado, sem depender de valores recém-atualizados. Em resumo, a abordagem Dataflow é didaticamente poderosa para estudar fluxo de dados, mantendo a eficiência de síntese equivalente à Behavioral.

### Implementação Structural

A implementação Structural leva o projeto para um nível mais baixo de abstração, aproximando-se da visão de esquemático em blocos. Em vez de descrever todo o comportamento dentro de um único módulo, criamos sub-blocos especializados: registros de ponteiro (`fifo_ptr_reg`), contador de ocupação (`fifo_count_reg`) e memória (`fifo_mem_block`). O módulo top-level se limita a interconectar esses blocos por meio de sinais internos. Essa estrutura modular é extremamente útil em contextos de **reuso de IP**: o mesmo bloco de contador, por exemplo, pode ser instanciado em diversos projetos diferentes.

Em termos de síntese, essa abordagem permite um controle mais explícito sobre a granularidade do hardware e sobre onde cada parte da lógica está localizada. Em FPGAs complexos, pode ser interessante agrupar certos blocos para facilitar o mapeamento em recursos específicos, como DSP blocks ou BRAMs. Entretanto, se a decomposição for exagerada, o código pode tornar-se mais verboso e mais difícil de manter. Para este exercício, o nível de decomposição escolhido é suficiente para ilustrar o conceito sem comprometer a legibilidade.

Por outro lado, a implementação Structural exige maior disciplina: qualquer alteração de interface precisa ser refletida em múltiplos módulos, e a depuração passa a envolver a análise de vários sinais intermediários. O testbench, felizmente, continua enxergando apenas a interface externa da FIFO, mantendo o mesmo conjunto de estímulos. Essa separação reforça a ideia de encapsulamento: internamente, cada abordagem pode mudar, desde que ofereça a mesma “caixa-preta” para o resto do sistema.

## 5.3 Descrição do Testbench

O testbench `tb_fifo_16_buffer_circular` foi projetado como um ambiente **auto-verificante**, capaz de validar simultaneamente as três implementações da FIFO. Para isso, ele instancia os módulos Behavioral, Dataflow e Structural em paralelo, conectando todos a um mesmo conjunto de sinais de estímulo: `clk`, `rst`, `wr_en`, `rd_en` e `data_in`. As saídas de cada implementação são capturadas em sinais dedicados (`data_out_beh`, `data_out_df`, `data_out_str`, bem como `full_*` e `empty_*`) e comparadas a cada borda de subida de clock. Qualquer divergência dispara uma mensagem detalhada de erro, indicando o ciclo em que ocorreu e os valores de cada implementação.

A geração do clock é feita por um processo `initial` que alterna o sinal `clk` a cada 5 ns, resultando em um período de 10 ns (100 MHz). O reset é aplicado de forma assíncrona no início da simulação por alguns ciclos, garantindo que todas as FIFOs partam de um estado bem definido. Em seguida, o testbench executa três fases principais de estímulos. Na primeira fase, a FIFO é **preenchida** com 16 valores consecutivos, garantindo que o flag `full` seja exercitado. Na segunda fase, operações de leitura e escrita ocorrem simultaneamente, simulando um cenário de **tráfego contínuo**, típico de pipelines. Por fim, a terceira fase realiza leituras sem novas escritas, até esvaziar a estrutura e testar o comportamento de `empty`.

Durante cada ciclo de estímulo, o testbench incrementa um contador de testes e imprime uma linha da **tabela didática** baseada na implementação Behavioral. Essa tabela inclui o tempo de simulação, os sinais de controle (`wr_en`, `rd_en`), o valor de `data_in` e o valor de `data_out_beh`, além dos flags `full` e `empty`. Assim, é possível acompanhar facilmente a dinâmica da FIFO sem precisar, obrigatoriamente, abrir a forma de onda. Ainda assim, o arquivo `wave.vcd` é gerado por meio das chamadas `$dumpfile` e `$dumpvars`, permitindo inspeção detalhada com ferramentas como GTKWave ou o próprio viewer do Questa.

Ao final da sequência de estímulos, o testbench verifica quantos erros foram contabilizados. Se o número de erros for zero, é exibida a mensagem exigida: **"SUCESSO: Todas as implementacoes estao consistentes em N testes."**. Caso contrário, uma mensagem de falha informa a quantidade de discrepâncias encontradas. O uso de `$finish` garante o encerramento limpo da simulação, evitando loops infinitos ou travamentos em ambientes automatizados de regressão. Dessa forma, o testbench atende aos requisitos de ser determinístico, totalmente reprodutível e adequado para integração em fluxos de CI/CD de projetos digitais mais amplos.

## 5.4 Aplicações Práticas

FIFOs com buffer circular, como a implementada neste projeto, estão presentes em uma enorme variedade de sistemas digitais reais. Em comunicações seriais, por exemplo, é comum utilizar uma FIFO entre a lógica de recepção de uma UART e o processador ou microcontrolador que fará o tratamento dos dados. A taxa de chegada dos bytes nem sempre coincide com os momentos em que o software está disponível para lê-los; a FIFO atua como um **amortecedor**, armazenando temporariamente os dados até que o processador possa consumi-los. Em aplicações de áudio e vídeo, FIFOs são usadas para compensar variações de latência entre produtores e consumidores de amostras, mantendo a continuidade de fluxo mesmo diante de pequenas flutuações de clock ou jitter.

Outra aplicação importante está em arquiteturas **streaming** e **pipelines de processamento**, como filtros digitais, codificadores/decodificadores e aceleradores de machine learning em FPGA. Nesses casos, uma FIFO pode separar estágios de processamento que trabalham em velocidades diferentes, garantindo que nenhum estágio fique permanentemente ocioso ou saturado. A parametrização de `DATA_WIDTH` e `DEPTH` permite ajustar o projeto às necessidades específicas de largura de dados e de capacidade de armazenamento, otimizando a utilização de memória no dispositivo. Por exemplo, em um sistema de coleta de dados de sensores, a profundidade da FIFO pode ser dimensionada para absorver picos de amostragem enquanto o barramento de comunicação externa está ocupado.

Além dessas aplicações clássicas, a FIFO parametrizável é um excelente bloco de construção para **interfaces de clock cruzado** (CDC), quando combinada com técnicas adequadas de sincronização. Embora o presente projeto utilize um único domínio de clock, a estrutura de ponteiros e buffer circular serve de base para FIFOs assíncronas, nas quais cada ponteiro é atualizado por um clock diferente. Nesses cenários, o controle de `full` e `empty` exige maior cuidado, mas o conceito permanece: entradas e saídas são desacopladas no tempo por um armazenamento intermediário ordenado. Em sistemas modernos de SoC e FPGA, esses buffers são fundamentais para conectar IPs com domínios de clock independentes.

Por fim, do ponto de vista educacional e profissional, dominar o projeto de FIFOs é um passo importante para quem pretende trabalhar com **sistemas embarcados, lógica reconfigurável e projeto digital em alto desempenho**. O mesmo padrão arquitetural se repete em controladores de DMA, filas de requisições em barramentos AXI, buffers de pacotes em redes on-chip e uma série de outros componentes. Ter uma implementação confiável, bem testada e parametrizável, como a desenvolvida aqui, facilita a montagem de sistemas maiores, reduz o retrabalho e melhora a qualidade global do projeto. Ao integrar este módulo em projetos futuros, basta ajustar profundidade e largura conforme a aplicação, mantendo a garantia de que as três abordagens produzem exatamente o mesmo comportamento funcional.
