# Projeto_fifo_8x16_buffer_barrel_shift

Autor: **Manoel Furtado**  
Data: **12/12/2025**  

## 5.1 Descrição do Projeto

Este projeto implementa uma FIFO de **8 palavras de 16 bits** usando a técnica de **barrel‑shift (Forma 1)**, conforme o enunciado. A ideia central é simplificar o controle de leitura: em vez de manter um ponteiro de leitura `rp`, a leitura ocorre sempre pela **cabeça da fila** (endereço 0). Assim, a saída `data_out` é simplesmente o conteúdo da posição 0 do buffer. O controle de ocupação é realizado por um contador `wp_count`, que representa quantas palavras válidas existem no buffer (varia de 0 até 8). As flags de status são derivadas diretamente desse contador: `empty=1` quando `wp_count==0`, e `full=1` quando `wp_count==DEPTH`. Dessa forma, o projeto fica coerente com a descrição do slide: cada escrita incrementa o ponteiro/contador de escrita e cada leitura decrementa esse valor.

Quando ocorre uma operação de leitura (`rd_en=1` e `empty=0`), o dado presente na cabeça é consumido e o buffer realiza um **deslocamento por palavra**: o conteúdo de `mem[1]` passa para `mem[0]`, o de `mem[2]` passa para `mem[1]`, e assim por diante, até que `mem[DEPTH-1]` receba zeros. Esse comportamento evidencia exatamente o requisito do exercício: “na operação de leitura a FIFO com barrel shift desloca a informação, inserindo zeros na cauda”. Além disso, o projeto também define um comportamento determinístico para o caso de operações simultâneas (`wr_en=1` e `rd_en=1`): quando não está nem cheia nem vazia, a FIFO primeiro efetua o deslocamento (remoção do elemento da cabeça) e em seguida escreve o novo valor na última posição válida (`wp_count-1`), mantendo a ocupação constante. Se estiver vazia e ocorrer `wr_en` e `rd_en` ao mesmo tempo, a leitura é ignorada e a escrita é tratada como inserção do primeiro elemento.

Para atender ao modelo de entrega, o projeto inclui **três implementações equivalentes**: Behavioral, Dataflow e Structural. Todas usam a mesma interface e a mesma semântica de controle, permitindo comparação automática. Além disso, incluímos uma FIFO de **referência com buffer circular** (ponteiros `rp/wp`) porque o enunciado pede comparar com a FIFO do exercício anterior. Em termos práticos, barrel‑shift é adequado para profundidades pequenas e situações em que se deseja saída sempre “alinhada” no índice 0, mas não é a melhor escolha para profundidades altas. A FIFO circular costuma ser mais eficiente em área e timing por mover apenas ponteiros, e o testbench deste projeto deixa essa comparação clara na simulação.

## 5.2 Análise das Abordagens

### Behavioral

A implementação **Behavioral** foi escrita com foco em clareza e aderência direta ao enunciado. Ela modela a memória como um vetor `mem[0:DEPTH-1]` e usa um contador `wp_count` para representar a ocupação atual. O deslocamento (barrel‑shift por palavra) é expresso com um laço `for`, que copia `mem[i+1]` para `mem[i]` e zera `mem[DEPTH-1]`. Esse estilo é tipicamente o mais rápido para escrever e o mais fácil para depurar em simulação, porque o código acompanha o raciocínio humano: “se ler, empurra tudo uma posição e limpa a última”. Em termos de síntese, a ferramenta tende a inferir um banco de flip‑flops e uma rede de multiplexação/roteamento correspondente ao deslocamento, o que é aceitável para `DEPTH=8`, mas pode ficar caro para valores grandes.

Outro ponto do Behavioral é o tratamento explícito de casos especiais: escrita quando `full=1` é ignorada; leitura quando `empty=1` é ignorada; no caso de `wr_en` e `rd_en` simultâneos, a lógica garante ocupação correta e evita latches (tudo ocorre em bloco sequencial). Para tornar o comportamento previsível e reduzir `X` na simulação, o reset também zera a memória inteira. Embora nem sempre seja necessário em hardware, isso é uma boa prática didática porque facilita a leitura das ondas e a interpretação das tabelas.

### Dataflow

A abordagem **Dataflow** separa explicitamente “lógica de próximo estado” e “registradores de estado”. Em vez de atualizar `mem` diretamente no bloco de clock, ela calcula uma cópia `mem_nxt[]` em um bloco combinacional `always @(*)` e, na borda de clock, faz `mem <= mem_nxt`. A vantagem prática é reduzir ambiguidades de múltiplas atribuições sequenciais e tornar visível o que é combinacional versus o que é registrado. Isso é particularmente útil quando existem condições sobrepostas (por exemplo, `wr_en` e `rd_en` simultâneos), pois a lógica combinacional pode aplicar uma prioridade clara sem depender do “último assignment” no mesmo `always @(posedge clk)`.

Em hardware, a diferença entre Behavioral e Dataflow pode ser pequena quando a síntese é boa, mas do ponto de vista de engenharia a abordagem dataflow facilita manutenção: é mais simples inserir assertivas, instrumentar sinais internos e revisar se a lógica de próximo estado cobre todos os casos. Como o objetivo do exercício é também comparar implementações, esse estilo ajuda a mostrar que diferentes organizações de código podem resultar em comportamento idêntico. O cuidado principal é garantir que `mem_nxt` sempre receba valores default para todas as posições (evitando inferência de latches), o que é feito no início do bloco combinacional com um laço que copia `mem` para `mem_nxt`.

### Structural

A implementação **Structural** busca explicitar o hardware ao usar registradores nomeados (`r0..r7`) em vez de arrays. O deslocamento na leitura vira uma cadeia direta `r0<=r1`, `r1<=r2`, etc., e a escrita é realizada por um `case(wp_count)` que seleciona qual registrador carregar. Essa descrição aproxima o código de um diagrama de blocos: um banco de registradores com caminhos de deslocamento e multiplexação por índice. A principal vantagem é a transparência para estudantes e para depuração visual (fica claro “onde” cada palavra está dentro do banco). Além disso, esse estilo pode facilitar restrições físicas ou inspeção de recursos em FPGA, pois cada registrador é um sinal nominal.

Do ponto de vista de síntese, Structural pode produzir resultados equivalentes ao Behavioral para `DEPTH` pequeno, mas tende a gerar mais lógica explícita (muxes do `case`) e não permite inferência de RAM. Por isso, ele é mais indicado quando a profundidade é curta ou quando o objetivo é aprendizagem. Em resumo: Behavioral é compacto e didático; Dataflow organiza o próximo estado de maneira mais clara; Structural explicita o hardware. Todos atendem ao mesmo contrato de interface, permitindo comparação automática no testbench. Os riscos de síntese e timing são dominados pelo deslocamento por palavra, não pelo estilo de codificação.

## 5.3 Descrição do Testbench

O testbench `tb_fifo_8x16_buffer_barrel_shift.v` foi projetado para ser **determinístico**, auto‑verificante e alinhado aos objetivos do Exercício 3. Ele gera um clock de 10 ns e aplica um reset assíncrono ativo em alto por alguns ciclos para garantir inicialização limpa. Em seguida, instancia simultaneamente as três DUTs (Behavioral, Dataflow e Structural) com os mesmos sinais de controle (`wr_en`, `rd_en`, `data_in`). A cada ciclo, o testbench executa duas verificações: (1) consistência entre as três implementações barrel‑shift; (2) consistência entre a implementação Behavioral barrel‑shift e uma FIFO de referência com buffer circular, configurada com o mesmo `DEPTH` e `DATA_WIDTH`. Essa dupla checagem atende ao requisito do enunciado de “comparar o funcionamento das duas FIFOs em simulação comportamental”.

Os estímulos são aplicados por uma tarefa `step()`, que configura os sinais e aguarda a borda de subida do clock, garantindo transições sequenciais claras e evitando loops infinitos. A cada passo, o testbench incrementa um contador de testes e, em caso de divergência, incrementa um contador de erros e imprime uma linha detalhada com tempo, entradas e saídas. Isso facilita localizar o instante exato em que a discrepância surgiu. Para visibilidade, o testbench gera um arquivo `wave.vcd` com `$dumpvars`, permitindo rastrear registradores internos no visualizador de ondas (por exemplo, observar o deslocamento da memória no barrel‑shift).

Além das checagens automáticas, o testbench imprime **quatro tabelas didáticas** baseadas em uma única abordagem (Behavioral), como requerido:  
- **Tabela 1**: escreve 8 valores conhecidos até `full=1` e tenta uma 9ª escrita, que deve ser ignorada.  
- **Tabela 2**: lê 8 vezes até `empty=1` e tenta uma leitura extra, que deve ser ignorada.  
- **Tabela 3**: escreve três valores (1111, 2222, 3333) e lê três vezes, evidenciando o deslocamento por palavra e a atualização da cabeça após cada leitura.  
- **Tabela 4**: mistura operações simultâneas (`wr_en=rd_en=1`) para validar que a ocupação se mantém estável quando ambas as operações são válidas.

Ao final, o testbench imprime obrigatoriamente: `"SUCESSO: Todas as implementacoes estao consistentes em %0d testes."` quando não há divergências, ou um relatório de falhas quando ocorrem inconsistências. Esse padrão cria um ambiente robusto para regressão: qualquer alteração futura na RTL é automaticamente validada.

## 5.4 Aplicações Práticas

FIFOs são blocos fundamentais em sistemas digitais reais porque resolvem um problema recorrente: **desacoplamento entre produtor e consumidor** de dados. Em aplicações de aquisição de sinais, por exemplo, um ADC pode produzir amostras continuamente a uma taxa fixa, enquanto um processador ou controlador consome essas amostras de forma intermitente (por interrupção, DMA ou janelas de processamento). A FIFO funciona como “pulmão” para absorver variações e reduzir a chance de overflow/underflow. Em pipelines de vídeo, é comum ter FIFOs para alinhar linhas e quadros; em áudio, para equalizar jitter entre domínios; em sistemas de rede, para amortecer bursts de tráfego e manter throughput.

A técnica de **barrel‑shift** é particularmente interessante quando a profundidade é pequena e o projeto busca simplicidade de leitura: sempre ler do índice 0 elimina a necessidade de um multiplexador de leitura baseado em `rp` e facilita inspeção em waveform (o próximo item aparece diretamente em `mem[0]`). Esse estilo pode ser útil em controladores com filas curtas, por exemplo: fila de até 8 comandos de um periférico, fila de eventos de uma FSM, ou fila de requisições em um bloco de arbitragem simples. Também pode aparecer em estruturas como “janela deslizante” de poucos elementos (por exemplo, manter os últimos 8 valores para um filtro simples), onde o deslocamento por amostra é natural e desejado.

Quando a profundidade cresce, a FIFO circular é quase sempre superior: ela altera apenas ponteiros e contador, e pode mapear muito bem para **Block RAM** em FPGAs. Isso reduz área e melhora timing, porque o custo por operação se aproxima de constante e independe de `DEPTH`. Em termos de risco de síntese, o barrel‑shift cria caminhos com múltiplas reatribuições por palavra e pode introduzir muxes maiores, tornando mais difícil fechar timing em frequências elevadas. Assim, na prática, uma boa estratégia é usar barrel‑shift como solução didática ou para buffers muito pequenos, e adotar FIFO circular quando o projeto exige escala. Independentemente da escolha, boas práticas incluem simulação auto‑verificante (como neste projeto), geração de ondas para inspeção e análise de relatórios de área/timing após síntese para garantir que a implementação atende aos requisitos do sistema.

