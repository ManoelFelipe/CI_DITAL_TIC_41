# Projeto ROM 16x8 Assíncrona em Verilog

## 5.1 Descrição do Projeto

Autor: *Manoel Furtado*  
Data: *10/12/2025*  

Este projeto implementa, em Verilog-2001, uma memória somente leitura assíncrona (ROM) com 16 posições de 8 bits cada, denominada **rom_16x8_async**. A funcionalidade básica desse bloco é receber um endereço de 4 bits e devolver imediatamente, sem o uso de clock, o dado correspondente a esse endereço. O mapa de memória segue exatamente o enunciado clássico de livros-texto de HDL: nos endereços de 0 a 15, são armazenados os valores de 0x00, 0x11, 0x22, ..., até 0xFF, em passos de 0x11. Trata-se, portanto, de um exemplo didático muito adequado para estudar modelagem de memórias em HDL, inferência de ROMs pela ferramenta de síntese e diferenças entre abordagens de descrição de hardware.

A arquitetura adotada é deliberadamente simples. Como se trata de uma ROM, não existe interface de escrita, nem sinais de habilitação. O módulo possui apenas um barramento de endereço (`address`) e um barramento de dados de saída (`data_out`). A leitura é puramente combinacional: qualquer alteração em `address` propaga o novo valor diretamente para `data_out` após o atraso de propagação associado à lógica inferida ou ao bloco de memória do FPGA. Isso facilita a análise de formas de onda e a introdução ao conceito de memórias assíncronas.

Do ponto de vista pedagógico, o projeto foi estruturado para atender a um conjunto de requisitos de engenharia de maior porte. Em vez de apresentar apenas uma implementação, são fornecidas **três versões equivalentes** da ROM: uma behavioral, uma dataflow e uma structural. Todas utilizam a mesma largura de barramentos e o mesmo mapa de memória, e todas são parametrizáveis em termos de `ADDR_WIDTH` e `DATA_WIDTH`, ainda que na prática o exercício use os valores padrão 4 e 8. Além disso, o repositório inclui um testbench único que instancia as três DUTs em paralelo, scripts `.do` para automação da simulação no Questa/ModelSim, e um `README` detalhado discutindo riscos de síntese, boas práticas e aplicações práticas para esse tipo de bloco.

---

## 5.2 Análise das Abordagens

### Implementação Behavioral

A implementação **behavioral** da ROM 16x8 é baseada em um bloco `always @*` contendo uma instrução `case` sobre o sinal de endereço. Para cada valor explícito de `address` entre 0 e 15, é atribuída uma constante hexadecimal à saída `data_out`. Essa é, provavelmente, a forma mais direta de modelar uma ROM pequena, porque a descrição se parece muito com uma tabela verdade escrita à mão. O uso de `always @*` garante que o bloco seja puramente combinacional, desde que todas as possibilidades de `address` sejam cobertas e que exista um ramo `default` que atribua algum valor seguro à saída. No código, o ramo `default` foi configurado como todos os bits em zero, evitando a inferência de latches ou a propagação de valores indefinidos (`X`).

Do ponto de vista de síntese, ferramentas modernas conseguem reconhecer um `case` denso com constantes e inferir automaticamente uma ROM implementada em LUTs ou em blocos dedicados de memória, dependendo do tamanho e da arquitetura do dispositivo. Para ROMs pequenas, como 16x8, é comum que o resultado seja simplesmente uma rede combinacional de LUTs. Isso tem como vantagem a latência de apenas um nível lógico e a ausência de necessidade de clock. Por outro lado, essa abordagem não escala bem para memórias muito grandes, pois o código fica extenso e difícil de manter, e a área de lógica pode crescer rapidamente.

Uma vantagem importante da abordagem behavioral é a legibilidade. Um estudante consegue enxergar, de forma imediata, a relação entre endereço e dado, sem precisar interpretar arrays, laços de inicialização ou multiplexadores explícitos. Essa clareza é útil em disciplinas introdutórias de HDL e também em revisões rápidas de código. Entretanto, para equipes grandes ou projetos complexos, a manutenção de longas instruções `case` pode se tornar propensa a erros de digitação e inconsistências.

### Implementação Dataflow

A implementação **dataflow** foi construída a partir de um array de registradores `rom_mem[0:DEPTH-1]`, onde cada posição armazena um vetor de 8 bits. Um bloco `initial` é responsável por inicializar todas as 16 posições com os valores exigidos pelo mapa de memória (0x00, 0x11, ..., 0xFF). A leitura da ROM é descrita por meio de uma atribuição contínua: `assign data_out = rom_mem[address];`. Essa linha sintetiza bem a ideia de dataflow, pois estabelece uma relação direta, contínua, entre o endereço e o dado de saída, sem recorrer a `always`.

Do ponto de vista de síntese, o uso de um array de registradores é frequentemente entendido pelo compilador como uma memória, especialmente quando os índices são direcionados por sinais de endereço e não há lógica extra em torno ao acesso. Em FPGAs, isso aumenta a chance de o bloqueio ser mapeado para recursos dedicados de memória (block RAMs ou ROMs embutidas), o que pode ser mais eficiente em área do que redes de LUTs, principalmente quando a ROM cresce de tamanho. Para este exemplo de 16x8, a diferença prática pode ser pequena, mas a abordagem demonstra um estilo mais escalável.

É importante notar que o bloco `initial` é usado majoritariamente em simulação. Em síntese, a forma como a memória é inicializada depende do fluxo usado; algumas ferramentas permitem especificar o conteúdo inicial por arquivos de memória externos (`.mif`, `.hex`, `$readmemh`), enquanto outras mapeiam a inicialização diretamente para os bits de configuração do FPGA. Do ponto de vista de boas práticas, a abordagem dataflow com array facilita a migração para esses mecanismos, pois basta substituir a lista explícita de atribuições por uma chamada a `$readmemh`, por exemplo.

### Implementação Structural

A implementação **structural** foi elaborada conectando explicitamente sinais internos que representam os conteúdos de cada endereço da ROM a um multiplexador 16:1 de 8 bits. Cada linha de memória é modelada como um `wire [7:0]` com valor constante: `rom_d0 = 8'h00`, `rom_d1 = 8'h11` e assim por diante até `rom_d15 = 8'hFF`. Todos esses sinais são entradas de um módulo `mux16x1_8bit`, cuja seleção é feita diretamente pelo endereço de 4 bits. O multiplexador, por sua vez, é descrito por um bloco `always @*` com instrução `case` sobre o sinal `sel`, retornando uma das 16 entradas.

Essa abordagem evidencia a estrutura física da ROM em termos de um banco de valores constantes e uma lógica de seleção. Do ponto de vista didático, ela ajuda a compreender que, internamente, a ROM pode ser vista como um conjunto de linhas contendo dados, onde apenas uma delas é conectada à saída em um dado instante. Em projetos maiores, essa visão estrutural é fundamental para o particionamento manual de lógica, reuso de componentes e análise de caminhos críticos.

Em termos de síntese, a implementação structural provavelmente será mapeada de forma semelhante à behavioral, resultando em rede de LUTs e multiplexadores. No entanto, o código deixa explícito o uso de um componente reutilizável (`mux16x1_8bit`), que pode ser substituído por variantes com pipeline, com enable ou com lógica de baixa potência, sem alterar a interface da ROM. A desvantagem é o aumento do volume de código e redução da legibilidade para ROMs muito maiores, tornando essa técnica mais adequada para blocos de controle ou ROMs pequenas e paramétricas.

---

## 5.3 Descrição do Testbench

O testbench `tb_rom_16x8_async` foi concebido para validar simultaneamente as três abordagens de implementação da ROM, garantindo consistência funcional e facilitando a análise das formas de onda. Ele define parâmetros locais `ADDR_WIDTH`, `DATA_WIDTH` e `DEPTH` para manter a simetria com os módulos DUTs e utiliza um registrador `address` compartilhado como estímulo de entrada. Em seguida, instanciamos as três versões da ROM – `rom_16x8_async_behavioral`, `rom_16x8_async_dataflow` e `rom_16x8_async_structural` – conectando todas ao mesmo sinal de endereço, de forma que qualquer alteração aplicada seja observada, ao mesmo tempo, em todas as saídas.

A metodologia de teste é baseada em varredura exaustiva dos 16 endereços válidos. Antes de iniciar o laço principal, uma tabela de referência `expected_rom[0:DEPTH-1]` é carregada com os mesmos valores do mapa de memória original. Isso permite não apenas comparar as implementações entre si, mas também verificar se o conteúdo corresponde ao esperado, detectando eventuais erros introduzidos por equívocos de digitação ou modificação indevida do código. Dois contadores são utilizados: `total_tests`, para registrar quantos casos foram avaliados, e `error_count`, para contabilizar as discrepâncias encontradas.

Durante o laço `for (i = 0; i < DEPTH; i = i + 1)`, o testbench aplica cada valor de endereço em sequência, aguarda um atraso de 10 ns para garantir a propagação dos sinais combinacionais e, em seguida, incrementa o número de testes. Em cada iteração, são feitas duas checagens fundamentais. A primeira verifica se as três saídas – `data_out_behavioral`, `data_out_dataflow` e `data_out_structural` – são idênticas. Caso haja divergência, uma mensagem de erro detalhada é impressa, indicando o endereço, bem como os três valores de saída. A segunda checagem compara a saída da implementação behavioral com o valor tabelado em `expected_rom[i]`, garantindo aderência ao mapa original de memória.

Além da verificação funcional, o testbench produz uma **tabela didática** que descreve o comportamento da ROM com base na implementação behavioral. Para cada endereço, uma linha é impressa utilizando `$display`, contendo o tempo simulado, o endereço em decimal e binário, e o dado em formato hexadecimal e binário. Essa tabela é extremamente útil tanto para conferir rapidamente a execução quanto para documentar o comportamento esperado em relatórios ou aulas. Para análise das formas de onda, o testbench inclui a geração de um arquivo `wave.vcd` por meio de `$dumpfile` e `$dumpvars`, permitindo inspeção em ferramentas como GTKWave ou equivalentes. Ao final, se `error_count` permanecer zero, é exibida a mensagem obrigatória de sucesso: `"SUCESSO: Todas as implementacoes estao consistentes em %0d testes."`, seguida da frase `"Fim da simulacao."` e a chamada a `$finish`, que encerra a simulação de forma limpa e determinística.

---

## 5.4 Aplicações Práticas

Memórias ROM assíncronas, como a `rom_16x8_async` deste projeto, têm papel relevante em diversas aplicações reais de sistemas embarcados e projetos digitais. Uma das utilizações mais clássicas é o armazenamento de tabelas de constantes para conversões ou funções não lineares. Por exemplo, em controladores de iluminação ou áudio, é comum precisar de curvas de resposta logarítmicas ou gamma-correction. Essas funções podem ser discretizadas e armazenadas em uma ROM, de forma que o sistema apenas consulta a tabela, sem precisar implementar operações matemáticas complexas em tempo real. Ainda que a ROM deste exemplo seja pequena (16 entradas), a técnica é escalável para tamanhos maiores, como 256x8 ou 1024x16, e o estilo de código adotado pode ser facilmente generalizado.

Outra aplicação prática é o uso de ROMs para implementar **máquinas de estados microprogramadas**. Em certos projetos, em vez de codificar a lógica de controle por meio de `case` aninhados ou grande quantidade de expressões booleanas, o projetista pode armazenar micro-instruções em uma memória somente leitura. Cada linha da ROM define sinais de controle para o datapath, e o endereço é derivado do estado atual e de sinais de condição. Embora o exemplo atual não implemente um microprograma, ele mostra a base de como declarar e acessar memórias em HDL, algo diretamente reutilizável em arquiteturas mais complexas, como controladores de barramento ou pequenos processadores.

Memórias ROM também aparecem na implementação de fontes de caracteres (font ROMs) para displays, tabelas de seno/cosseno em moduladores PWM, coeficientes de filtros em sistemas de processamento de sinais e em lookup-tables para correção de sensoriamento (linearização de sensores de temperatura, pressão, etc.). Em todos esses cenários, a principal vantagem é trocar a complexidade de cálculo por um acesso simples a memória, reduzindo o tempo de resposta e, muitas vezes, economizando área de lógica combinacional. No contexto de FPGAs modernos, utilizar blocos de memória dedicados costuma ser mais eficiente em termos de consumo de recursos e de energia do que sintetizar expressões matemáticas extensas.

Por fim, o fato de o projeto ter sido estruturado com três abordagens — behavioral, dataflow e structural — torna-o um excelente ponto de partida para estudos adicionais. O aluno pode, por exemplo, adaptar a ROM para armazenar coeficientes de um filtro FIR, expandindo `DATA_WIDTH` e `DEPTH`, ou integrar a ROM a um datapath já existente de ULA, contador e registradores de saída. Também é possível transformar a ROM em uma RAM, adicionando sinais de escrita e enable, aproximando-se de exemplos reais de buffers de vídeo, memória de configuração ou armazenamento de chaves criptográficas. Dessa forma, este exercício deixa de ser apenas um problema de livro e se transforma em um bloco reutilizável, com aplicações concretas em projetos profissionais de FPGA e ASIC.

